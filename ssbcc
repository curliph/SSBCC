#!/usr/bin/python

################################################################################
#
# Copyright 2012, Sinclair R.F., Inc.
#
# Build an SSBCC system.
#
################################################################################

import math
import os
import re
import sys
import tempfile

from ssbccUtil import *;

################################################################################
#
# Process the more complicated configuration commands.
#
################################################################################

def processInport(config,line):
  cmd = re.findall(r'\s*INPORT\s+(\S+)\s+(\S+)\s+(\w+)',line);
  modes = re.findall(r'([^,]+)',cmd[0][0]);
  names = re.findall(r'([^,]+)',cmd[0][1]);
  portName = cmd[0][2];
  if len(modes) != len(names):
    raise SSBCCException('Malformed INPORT configuration command -- number of options don\'t match on line %d: "%s"' % (ixLine,line[:-1],));
  # Append the input signal names, mode, and bit-width to the list of I/Os.
  has__set_reset = False;
  nBits = 0;
  thisPort = (portName,);
  for ix in range(len(names)):
    if re.match(r'^\d+-bit$',modes[ix]):
      thisNBits = int(modes[ix][0]);
      config['ios'].append((names[ix],thisNBits,'input',));
      thisPort += ((names[ix],thisNBits,'data',),);
      nBits = nBits + thisNBits;
    elif modes[ix] == 'set-reset':
      has__set_reset = True;
      config['ios'].append((names[ix],1,'input',));
      thisPort += ((names[ix],1,'set-reset',),);
      config['signals'].append(('s_SETRESET_%s' % names[ix],1,));
    elif modes[ix] == 'strobe':
      config['ios'].append((names[ix],1,'output',));
      thisPort += ((names[ix],1,'strobe',),);
    else:
      raise SSBCCException('Unrecognized INPORT signal type "%s"' % modes[ix]);
    if has__set_reset and len(names) > 1:
      raise SSBCCException('set-reset cannot be simultaneous with other signals in "%s"' % line[:-1]);
    if nBits > 8:
      raise SSBCCException('Signal width too wide in "%s"' % line[:-1]);
  config['inports'].append(thisPort);

def processOutport(config,line,ixLine):
  cmd = re.findall(r'^\s*OUTPORT\s+(\S+)\s+(\S+)\s+(\w+)\s*$',line);
  if not cmd:
    raise SSBCCException('Malformed OUTPUT configuration command on line %d: "%s"' % (ixLine,line[:-1],));
  modes = re.findall(r'([^,]+)',cmd[0][0]);
  names = re.findall(r'([^,]+)',cmd[0][1]);
  portName = cmd[0][2];
  if len(modes) != len(names):
    raise SSBCCException('Malformed OUTPORT configuration command -- number of widths/types and signal names don\'t match on line %d: "%s"' % (ixLine,line[:-1],));
  # Append the input signal names, mode, and bit-width to the list of I/Os.
  nBits = 0;
  thisPort = (portName,);
  for ix in range(len(names)):
    if re.match(r'\d+-bit',modes[ix]):
      a = re.match(r'(\d+)-bit(=\S+)?$',modes[ix]);
      if not a:
        raise SSBCCException('Malformed bitwith/bitwidth=initialization on line %d:  "%s"' % (ixLine,modes[ix],));
      thisNBits = int(a.group(1));
      config['ios'].append((names[ix],thisNBits,'output',));
      if a.group(2):
        thisPort += ((names[ix],thisNBits,'data',a.group(2)[1:],),);
      else:
        thisPort += ((names[ix],thisNBits,'data',),);
      nBits = nBits + thisNBits;
      config['haveBitOutportSignals'] = 'True';
    elif modes[ix] == 'strobe':
      config['ios'].append((names[ix],1,'output',));
      thisPort += ((names[ix],1,'strobe',),);
    else:
      raise SSBCCException('Unrecognized OUTPORT signal type on line %d: "%s"' % (ixLine,modes[ix],));
    if nBits > 8:
      raise SSBCCException('Signal width too wide on line %d:  in "%s"' % (ixLine,line[:-1],));
  config['outports'].append(thisPort);

def processPeripheral(config,ixLine,line):
  # Validate the format of the peripheral configuration command and the the name of the peripheral.
  cmd = re.findall(r'\s*PERIPHERAL\s+(\w+)\s*(.*)',line);
  if not cmd:
    raise SSBCCException('Missing peripheral name in line %d:  %s' % (ixLine,line[:-1],));
  peripheral = cmd[0][0];
  # Find and execute the peripheral Python script.
  for testPath in config['peripheralpaths']:
    fullperipheral = os.path.join(testPath,'%s.py' % peripheral);
    if os.path.isfile(fullperipheral):
      break;
  else:
    raise SSBCCException('Peripheral "%s" not found' % peripheral);
  execfile(fullperipheral);
  # Convert the space delimited parameters to a list of tuples.
  param_list = list();
  for param_string in re.findall(r'(\w+="[^"]*"|\w+=\S+|\w+)\s*',cmd[0][1]):
    if param_string == "help":
      exec('helpmsg = %s.__doc__' % peripheral);
      if not helpmsg:
        raise SSBCCException('No help for peripheral %s is provided' % fullperipheral);
      print;
      print 'Help message for peripheral:  %s' % peripheral;
      print 'Located at:  %s' % fullperipheral;
      print;
      print helpmsg;
      raise SSBCCException('Terminated by "help" for peripheral %s' % peripheral);
    ix = param_string.find('=');
    if param_string.find('="') > 0:
      param_list.append((param_string[:ix],param_string[ix+2:-1],));
    elif param_string.find('=') > 0:
      param_list.append((param_string[:ix],param_string[ix+1:],));
    else:
      param_list.append((param_string,None));
  # Add the peripheral to the micro controller configuration.
  exec('config[\'peripheral\'].append(%s(config,param_list,ixLine));' % peripheral);

################################################################################
#
# Surround the program with a try ... except clause
#
################################################################################

try:

  ################################################################################
  #
  # Parse the command line arguments
  #
  ################################################################################

  #
  # Construct the command-line argument list parser
  #

  import argparse
  argListParser = argparse.ArgumentParser(description='SSBCC system builder');
  argListParser.add_argument('-P', metavar='peripheral_name[="parameters"]', type=str, action='append', help='Add peripheral');
  argListParser.add_argument('--define-clog2', action='store_true', help='define clog2 instead of using built-in $clog2');
  argListParser.add_argument('--verilator-tracing-on', action='store_true', help='show all signals in verilator waveform files');
  argListParser.add_argument('filename', metavar='filename', type=file, help='SSBCC configuration file');
  argList = argListParser.parse_args();

  #
  # Read the SSBCC configuration file.
  #

  config = dict(peripheral=list());
  config['constants']   = list();
  config['inports']     = list();
  config['ios']         = list();
  config['signals']     = list();
  config['outports']    = list();
  config['parameters']  = list();
  config['functions']   = dict();

  config['define_clog2'] = argList.define_clog2;
  config['verilator_tracing_on'] = argList.verilator_tracing_on;

  config['peripheralpaths'] = list();
  config['peripheralpaths'].append('.');
  config['peripheralpaths'].append('peripherals');
  config['peripheralpaths'].append(os.path.join(sys.path[0],'core/peripherals'));

  ixLine = 0;
  bufLine = "";
  compiler = [];
  memories = dict(list=list(), type=list(), arch=list());
  user_header = list();
  for tmpLine in argList.filename:
    ixLine = ixLine + 1;
    # Merge continuation lines.
    bufLine += tmpLine;
    if bufLine[-2:] == '\\\n':
      bufLine = bufLine[:-2];
      continue;
    line = bufLine;
    bufLine = "";
    # Reject blank and comment lines
    if re.match(r'\s*(#.*)?$',line):
      pass;
    # ARCHITECTURE
    elif re.match(r'\s*ARCHITECTURE\b',line):
      if 'architecture' in config:
        raise SSBCCException('ARCHITECTURE already specified before line %d' % line[:-1]);
      cmd = re.findall(r'\s*ARCHITECTURE\s+(\S+)',line);
      if not cmd:
        raise SSBCCException('Malformed ARCHITECTURE configuration command on line %d: "%s"' % (ixLine,line[:-1],));
      config['architecture'] = cmd[0];
      corepath = os.path.join(sys.path[0],config['architecture']);
      if not os.path.isdir(corepath):
        raise SSBCCException('Architecture "%s" does not exist at line %d' % (cmd,line[:-1],));
      config['peripheralpaths'].insert(-1,os.path.join(corepath,'peripherals'));
    # ASSEMBLY language for processor code
    elif re.match(r'\s*ASSEMBLY\b',line):
      cmd = re.findall(r'\s*ASSEMBLY\s+(\S.*)',line);
      compiler = ('asm',cmd[0],);
    # COMBINE
    elif re.match(r'\s*COMBINE\b',line):
      cmd = re.findall(r'\s*COMBINE\s+(\S+),(\S+)',line);
      if (not cmd) or (len(cmd[0]) < 2):
        raise SSBCCException('Malformed "COMBINE" configuration command on line %d: "%s"' % (ixLine,line[:-1],));
      combine = (cmd[0][0],cmd[0][1],);
    # CONSTANTS
    elif re.match(r'\s*CONSTANT\b',line):
      cmd = re.findall(r'\s*CONSTANT\s+(C_\w+)\s+(\w+)\s*$',line);
      if not cmd:
        raise SSBCCException('Malformed "CONSTANT" configuration command on line %d: "%s"' % (ixLine,line[:-1],));
      cmd = cmd[0];
      config['constants'].append((cmd[0],cmd[1],));
    # DATA_STACK
    elif re.match(r'\s*DATA_STACK\b',line):
      if 'data_stack' in config:
        raise SSBCCException('DATA_STACK already defined before line %d' % line[:-1]);
      cmd = re.findall(r'\s*DATA_STACK\s+([1-9]\d*)',line);
      if not cmd:
        raise SSBCCException('Malformed "DATA_STACK" configuration command on line %d: "%s"' % (ixLine,line[:-1],));
      config['data_stack'] = int(cmd[0]);
    # HDL
    elif re.match(r'\s*HDL\s',line):
      if 'hdl' in config:
        raise SSBCCException('HDL already specified before line %d' % line[:-1]);
      cmd = re.findall(r'\s*HDL\s+(\S*)\s+(\S*)', line);
      if cmd[0][0] in ('Verilog','VHDL',):
        config['hdl'] = cmd[0][0];
        outCoreName = cmd[0][1];
      else:
        raise Exception('Unrecognized HDL: "%s"' % cmd[0]);
    # INPORT
    elif re.match(r'\s*INPORT\b',line):
      processInport(config,line);
    # INSTRUCTION
    elif re.match(r'\s*INSTRUCTION\b',line):
      if 'nInstructions' in config:
        raise SSBCCException('INSTRUCTION already specified before line %d' % line[:-1]);
      cmd = re.findall(r'\s*INSTRUCTION\s+([1-9]\d*)',line);
      if not cmd:
        raise SSBCCException('Malformed "INSTRUCTION" configuration command on line %d: "%s"' % (ixLine,line[:-1],));
      config['nInstructions'] = int(cmd[0]);
      if config['nInstructions'] > 2**13:
        raise SSBCCException('Instruction space cannot exceed %d' % (2**13));
    # MEMORY
    elif re.match(r'\s*MEMORY\b',line):
      if len(memories['list']) >= 4:
        raise SSBCCException('Program is limited to 4 memories');
      cmd = re.findall(r'\s*MEMORY\s+(\S+)\s+(\S+)\s+(\S+)\s*$',line);
      if (not cmd) or (len(cmd[0]) != 3):
        raise SSBCCException('Malformed MEMORY configuration command on line %d: "%s"' % (ixLine,line[:-1],));
      cmd = cmd[0];
      memories['type'].append(cmd[0]);
      memories['list'].append(cmd[1]);
      memories['arch'].append(cmd[2]);
    # OUTPORT
    elif re.match(r'\s*OUTPORT\b',line):
      processOutport(config,line,ixLine);
    # PARAMETER
    elif re.match(r'\s*PARAMETER\b',line):
      cmd = re.findall(r'\s*PARAMETER\s+(\w+)\s+(\d+)',line);
      if (not cmd) or (len(cmd[0]) != 2):
        raise SSBCCException('Malformed PARAMETER configuration command on line %d: "%s"' % (ixLine,line[:-1],));
      cmd = cmd[0];
      config['parameters'].append((cmd[0],cmd[1],));
    # PERIPHERAL
    elif re.match(r'\s*PERIPHERAL\b',line):
      processPeripheral(config,ixLine,line);
    # PORTCOMMENT
    elif re.match(r'\s*PORTCOMMENT\b',line):
      cmd = re.findall(r'\s*PORTCOMMENT\s+(.*)',line[:-1]);
      config['ios'].append((cmd[0],0,'comment',));
    # RETURN_STACK
    elif re.match(r'\s*RETURN_STACK\b',line):
      if 'return_stack' in config:
        raise SSBCCException('RETURN_STACK already specified before line %d' % line[:-1]);
      cmd = re.findall(r'\s*RETURN_STACK\s+([1-9]\d*)',line);
      if not cmd:
        raise SSBCCException('Malformed "RETURN_STACK" configuration command on line %d: "%s"' % (ixLine,line[:-1],));
      config['return_stack'] = int(cmd[0]);
    # USER_HEADER
    elif re.match(r'\s*USER_HEADER\b',line):
      user_header_done = False;
      for line in argList.filename:
        ixLine = ixLine + 1;
        if re.match(r'\s*END_USER_HEADER\s',line):
          user_header_done = True;
          break;
        user_header.append(line[0:-1]);
      if not user_header_done:
        raise SSBCCException('No "END_USER_HEADER" found for "USER_HEADER"');
    # error
    else:
      raise SSBCCException('Unrecognized configuration command on line %d: "%s"' % (ixLine,line[:-1],));
  argList.filename.close();

  #
  # Append peripherals from command-line.
  #

  if argList.P:
    for peripheral in argList.P:
      processPeripheral(config,-1,'PERIPHERAL '+peripheral);

  #
  # end-of-file processing
  #

  if 'architecture' not in config:
    raise SSBCCException('Required ARCHITECTURE configuration command missing');
  if 'data_stack' not in config:
    raise SSBCCException('Required DATA_STACK configuration command missing');
  if 'hdl' not in config:
    raise SSBCCException('Required HDL configuration command missing');
  if 'nInstructions' not in config:
    raise SSBCCException('Required INSTRUCTION configuration command missing');
  if 'return_stack' not in config:
    raise SSBCCException('Required RETURN_STACK configuration command missing');

  # Compute the memory bank indices.
  ixRAM = 0;
  ixROM = 3;
  memories['bank'] = list();
  memories['length'] = list();
  memories['body'] = list();
  for memType in memories['type']:
    memories['bank'].append(None);
    memories['length'].append(None);
    memories['body'].append(None);

  ################################################################################
  #
  # Compile the processor code and read the tables it generated.
  #
  ################################################################################

  # Compute the file name to store the assembler output
  assemblerOutput = os.path.splitext(argList.filename.name)[0]+'.9x8-meta'

  # Compute the command to invoke the compiler.
  cmd = os.path.join(corepath, compiler[0]);
  for ix in range(len(config['constants'])):
    cmd += (' -C %s=%s' % (config['constants'][ix][0],config['constants'][ix][1],));
  for ix in range(len(config['inports'])):
    cmd += (' -I %s=%d' % (config['inports'][ix][0],ix));
  for ix in range(len(config['outports'])):
    cmd += (' -O %s=%d' % (config['outports'][ix][0],ix));
  for ix in range(len(config['parameters'])):
    cmd += (' -P %s' % config['parameters'][ix][0]);
  for ix in range(len(memories['list'])):
    cmd += (' -S %s=%d' % (memories['list'][ix],eval(memories['arch'][ix])));
  cmd += ' -o ' + assemblerOutput;
  cmd += ' -L %s/%s' % (sys.path[0], 'lib/9x8');
  cmd += ' ' + compiler[1];

  # Invoke the compiler and exit if it failed.
  print 'Invoking the assember with the following command:  ' + cmd;
  cmdStatus = os.system(cmd);
  if cmdStatus != 0:
    raise SSBCCException('Running the assembler');

  # Read the assembler output tables.
  fpAssemberOutput = open(assemblerOutput,'r');
  ixLine = 0;
  programBody = list();
  programBodyLength = 0;
  for line in fpAssemberOutput:
    ixLine = ixLine + 1;
    # blank line
    if re.match('^\s*$',line):
      continue;
    # memory type, name, and length
    elif re.match(':memory',line):
      cmd = re.findall(':memory (\S+) (\S+) (\S+) (\S+)',line);
      cmd = cmd[0];
      if cmd[1] not in memories['list']:
        raise SSBCCException('%s "%s" not declared %s' % (cmd[0],cmd[1],argList.filename,));
      ixMem = memories['list'].index(cmd[1]);
      if memories['type'][ixMem] != cmd[0]:
        raise SSBCCException('Type of memory "%s" is inconsistent' % cmd[1]);
      if int(cmd[2]) > eval(memories['arch'][ixMem]):
        raise SSBCCException('Length of memory "%s" = %s which exceeds limit of %d' % (cmd[1],cmd[2],eval(memories['arch'][ixMem]),));
      memories['bank'][ixMem] = int(cmd[2]);
      memories['length'][ixMem] = cmd[3];
      memoryBody = list();
      for line in fpAssemberOutput:
        ixLine = ixLine + 1;
        if len(line) <= 1:
          memories['body'][ixMem] = memoryBody;
          break;
        memoryBody.append(line)
    # program .main, optional .interrupt, and length
    elif re.match(':program',line):
      cmd = re.findall(':program (\d+) (\S+) (\d+)',line);
      mainStart = int(cmd[0][0]);
      if cmd[0][1] == '[]':
        interruptStart = -1;
      else:
        interruptStart = int(cmd[0][1]);
      mainLength = int(cmd[0][2]);
      for line in fpAssemberOutput:
        ixLine = ixLine + 1;
        if len(line) <= 1:
          break;
        programBody.append(line[0:-1]);
        if line[0] != '-':
          programBodyLength = programBodyLength + 1;
      if programBodyLength != mainLength:
        raise SSBCCException('Program Bug:  program length doesn\'t match declared length');
      if programBodyLength > config['nInstructions']:
        raise SSBCCException('Program body length = %d is longer than the allocated instruction table = %d' % (programBodyLength,config['nInstructions'],));
    else:
      raise SSBCCException('Unrecognized line at %s:%d :  %s' % (fpAssemberOutput.filename,ixLine,line[:-1],));

  ################################################################################
  #
  # Ensure the processor has been consistently defined.
  #
  ################################################################################

  # Ensure all desired memories are used.
  for ixMem in range(len(memories['list'])):
    if not memories['length'][ixMem]:
      raise SSBCCException('Memory "%s" not used in program' % memories['list'][ixMem]);

  ################################################################################
  #
  # Generate the processor core.
  #
  ################################################################################

  if config['hdl'] == 'Verilog':
    from ssbccGenVerilog import *;
  else:
    raise SSBCCException('Unrecognized hdl = "%s"' % config['hdl']);

  if config['hdl'] == 'Verilog':
    fpRawCore = open(os.path.join(corepath,'core.v'),'r');
    fpOutCore = open(outCoreName+'.v','w');
  elif config['hdl'] == 'VHDL':
    fpRawCore = open(os.path.join(corepath,'core.vhd'),'r');
    fpOutCore = open(outCoreName+'.vhd','w');
  else:
    raise Exception('Program Bug:  unrecognized hdl = "%s"', config['hdl']);

  for line in fpRawCore:
    if not re.match('..@SSBCC@',line):
      fpOutCore.write(line);
      continue;
    fillCommand = re.findall('..@SSBCC@\s+(\S+)',line)[0];
    # inports
    if fillCommand == 'inports':
      genInports(fpOutCore,config);
    # instructions
    elif fillCommand == 'instructions':
      genInstructions(fpOutCore,programBody,config);
    # localparam
    elif fillCommand == 'localparam':
      genLocalParam(fpOutCore,config);
    # memory
    elif fillCommand == 'memory':
      genMemory(fpOutCore,memories);
    # module
    elif fillCommand == 'module':
      genModule(fpOutCore,outCoreName,config);
    # outports
    elif fillCommand == 'outports':
      genOutports(fpOutCore,config);
    # peripherals
    elif fillCommand == 'peripherals':
      if config['peripheral']:
        fpOutCore.write('//\n// Peripherals\n//\n');
      for ix in range(len(config['peripheral'])):
        fpOutCore.write('\n');
        config['peripheral'][ix].GenHDL(fpOutCore,config);
    # additional signals
    elif fillCommand == 'signals':
      genSignals(fpOutCore,config);
    # user_header
    elif fillCommand == 'user_header':
      genUserHeader(fpOutCore,user_header);
    # Verilator tracing on/off
    elif fillCommand == "verilator_tracing":
      if config['verilator_tracing_on']:
        fpOutCore.write('/* verilator tracing_on */\n');
      else:
        fpOutCore.write('/* verilator tracing_off */\n');
    # error
    else:
      print 'WARNING:  Unimplemented command ' + fillCommand;

################################################################################
#
# Terminating except clause
#
################################################################################

except SSBCCException, msg:
  print >> sys.stderr, 'FATAL ERROR:  ' + str(msg);
  exit(1);
