#!/usr/bin/python

################################################################################
#
# Copyright 2012, Sinclair R.F., Inc.
#
# Build an SSBCC system.
#
################################################################################

import math
import os
import re
import sys
import tempfile

################################################################################
#
# Useful functions.
#
################################################################################

def CeilLog2(v):
  tmp = int(math.log(v,2));
  while 2**tmp < v:
    tmp = tmp + 1;
  return tmp;

def IsPowerOf2(v):
  return v == 2**int(math.log(v,2)+0.5);

################################################################################
#
# Parse the command line arguments
#
################################################################################

#
# Construct the command-line argument list parser
#

import argparse
argListParser = argparse.ArgumentParser(description='SSBCC system builder');
argListParser.add_argument('filename', metavar='filename', type=file, help='SSBCC configuration file');
argList = argListParser.parse_args();

#
# Read the SSBCC configuration file.
#

ixLine = 0;
compiler = [];
data_stack = 0;
inport = dict(config=list(), name=list(), id=list());
instruction = 0;
memories = list();
outport = dict(config=list(), name=list(), id=list());
return_stack = 0;
user_header = list();
for line in argList.filename:
  ixLine = ixLine + 1;
  # Reject blank and comment lines
  if re.match(r'\s*(#.*)?$',line):
    pass;
  # ARCHITECTURE
  elif re.match(r'\s*ARCHITECTURE\b',line):
    cmd = re.findall(r'\s*ARCHITECTURE\s+(\S+)',line);
    if not cmd:
      raise Exception('Malformed ARCHITECTURE statement on line %d: "%s"' % (ixLine,line));
    architecture=cmd[0];
  # ASSEMBLY language for processor code
  elif re.match(r'\s*ASSEMBLY\b',line):
    cmd = re.findall(r'\s*ASSEMBLY\s+(\S.*)',line);
    compiler = ('asm',cmd[0],);
  # COMBINE
  elif re.match(r'\s*COMBINE\b',line):
    cmd = re.findall(r'\s*COMBINE\s+(\S+),(\S+)',line);
    if (not cmd) or (len(cmd[0]) < 2):
      raise Exception('Malformed "COMBINE" command on line %d: "%s"' % (ixLine,line));
    combine = (cmd[0][0],cmd[0][1],);
  # DATA_STACK
  elif re.match(r'\s*DATA_STACK\b',line):
    cmd = re.findall(r'\s*DATA_STACK\s+([1-9]\d*)',line);
    if not cmd:
      raise Exception('Malformed "DATA_STACK" command on line %d: "%s"' % (ixLine,line));
    data_stack = int(cmd[0]);
  # HDL
  elif re.match(r'\s*HDL\s',line):
    cmd = re.findall(r'\s*HDL\s+(\S*)\s+(\S*)', line);
    if cmd[0][0] in ('Verilog','VHDL',):
      hdl = cmd[0][0];
      outCoreName = cmd[0][1];
    else:
      raise Exception('Unrecognized HDL: "%s"' % cmd[0]);
  # INPORT
  elif re.match(r'\s*INPORT\b',line):
    cmd = re.findall(r'\s*INPORT\s+(\S+)\s+(\S+)\s+(\w+)',line);
    configs = re.findall(r'([^,]+)',cmd[0][0]);
    names = re.findall(r'([^,]+)',cmd[0][1]);
    if len(configs) != len(names):
      raise Exception('Malformed INPORT statement -- number of options don\'t match on line %d: "%s"' % (ixLine,line));
    inport['config'].append(configs);
    inport['name'].append(names);
    inport['id'].append(cmd[0][2]);
  # INSTRUCTION
  elif re.match(r'\s*INSTRUCTION\b',line):
    cmd = re.findall(r'\s*INSTRUCTION\s+([1-9]\d*)',line);
    if not cmd:
      raise Exception('Malformed "INSTRUCTION" command on line %d: "%s"' % (ixLine,line));
    instruction = int(cmd[0]);
  # MEMORY
  elif re.match(r'\s*MEMORY\b',line):
    cmd = re.findall(r'\s*MEMORY\s+(\S+)\s+(\S+)',line);
    if (not cmd) or (len(cmd[0])<2):
      raise Exception('Malformed MEMORY statement on line %d: "%s"' % (ixLine,line));
    memories.append(cmd[0]);
  # OUTPORT
  elif re.match(r'\s*OUTPORT\b',line):
    cmd = re.findall(r'\s*OUTPORT\s+(\S+)\s+(\S+)\s+(\w+)',line);
    configs = re.findall(r'([^,]+)',cmd[0][0]);
    names = re.findall(r'([^,]+)',cmd[0][1]);
    if len(configs) != len(names):
      raise Exception('Malformed INPORT statement -- number of options don\'t match on line %d: "%s"' % (ixLine,line));
    outport['config'].append(configs);
    outport['name'].append(names);
    outport['id'].append(cmd[0][2]);
  # RETURN_STACK
  elif re.match(r'\s*RETURN_STACK\b',line):
    cmd = re.findall(r'\s*RETURN_STACK\s+([1-9]\d*)',line);
    if not cmd:
      raise Exception('Malformed "RETURN_STACK" command on line %d: "%s"' % (ixLine,line));
    return_stack = int(cmd[0]);
    if not IsPowerOf2(return_stack):
      raise Exception('"RETURN_STACK" value must be a power of 2 on line %d: "%s"' % (ixLine,line));
  # USER_HEADER
  elif re.match(r'\s*USER_HEADER\b',line):
    user_header_done = False;
    for line in argList.filename:
      if re.match(r'\s*END_USER_HEADER\s',line):
        user_header_done = True;
        break;
      user_header.append(line[0:-1]);
    if not user_header_done:
      raise Exception('No "END_USER_HEADER" found for "USER_HEADER"');
  # error
  else:
    raise Exception('Unrecognized configuration command on line %d: "%s"' % (ixLine,line));
argList.filename.close();

corepath = '%s/%s' % (sys.path[0], architecture);

################################################################################
#
# Compile the processor code and read the tables it generated.
#
################################################################################

# Generate a random name for the temporary file holding the compiler output.
# Ensure the temporary file is located off of the project path instead of
# accumulating in /tmp.
assemblerOutput = tempfile.mktemp(prefix='tmp-',suffix='.asm');
assemblerOutput = os.path.basename(assemblerOutput);
assemblerOutput = os.path.join('tmp',assemblerOutput);

if not os.path.exists('tmp'):
  os.mkdir('tmp');

# Compute the command to invoke the compiler.
cmd = os.path.join(corepath, compiler[0]);
for ix in range(len(inport['config'])):
  cmd += (' -I %s=%d' % (inport['id'][ix],ix));
for ix in range(len(outport['config'])):
  cmd += (' -O %s=%d' % (outport['id'][ix],ix));
cmd += ' -o ' + assemblerOutput;
cmd += ' -L %s/%s' % (sys.path[0], 'lib/9x8');
cmd += ' ' + compiler[1];

# Invoke the compiler and exit if it failed.
print 'Invoking the assember with the following command:  ' + cmd;
cmdStatus = os.system(cmd);
if cmdStatus != 0:
  raise Exception('FATAL ERROR running the assembler');

# Read the assembler output tables.
fpAssemberOutput = open(assemblerOutput,'r');
programBody = list();
programBodyLength = 0;
for line in fpAssemberOutput:
  if re.match(':program',line):
    cmd=re.findall(':program (\d+) (\S+) (\d+)',line);
    mainStart = int(cmd[0][0]);
    if cmd[0][1] == '[]':
      interruptStart = -1;
    else:
      interruptStart = int(cmd[0][1]);
    mainLength = int(cmd[0][2]);
    for line in fpAssemberOutput:
      if len(line) <= 1:
        break;
      programBody.append(line[0:-1]);
      if line[0] != '-':
        programBodyLength = programBodyLength + 1;
    if programBodyLength != mainLength:
      raise Exception('Program Bug:  program length doesn\'t match declared length');
    if programBodyLength > instruction:
      raise Exception('Program body length = %d is longer than the allocated instruction table = %d' % (programBodyLength,instruction));

################################################################################
#
# Generate the processor core.
#
################################################################################

inports_have_bitsignals = False;

if hdl == 'Verilog':
  fpRawCore = open(os.path.join(corepath,'core.v'),'r');
  fpOutCore = open(outCoreName+'.v','w');
elif hdl == 'VHDL':
  fpRawCore = open(os.path.join(corepath,'core.vhd'),'r');
  fpOutCore = open(outCoreName+'.vhd','w');
else:
  raise Exception('Program Bug:  unrecognized hdl = "%s"', hdl);
for line in fpRawCore:
  if not re.match('..@SSBCC@',line):
    fpOutCore.write(line);
    continue;
  fillCommand = re.findall('..@SSBCC@\s+(\S+)',line)[0];
  # inports
  if fillCommand == 'inports':
    if inport['config']:
      if inports_have_bitsignals:
        fpOutCore.write('always @ (*)\n');
        fpOutCore.write('  case (s_T)\n');
        for ix in range(len(inport['config'])):
          configs = inport['config'][ix];
          names = inport['name'][ix];
          for jx in range(len(configs)):
            if re.match(r'\d+-bit',configs[jx]):
              a = re.findall(r'(\d+)',configs[jx]);
              portLength = int(a[0]);
              if portLength < 8:
                fpOutCore.write('      8\'h%02X : s_T_inport <= { %d\'h0, %s };\n' % (ix,8-portLength,inport['name'][ix][jx]));
              else:
                fpOutCore.write('      8\'h%02X : s_T_inport <= %s;\n' % (ix,inport['name'][ix][jx]));
        fpOutCore.write('    default : s_T_inport <= 8\'h00;\n');
        fpOutCore.write('  endcase\n');
        fpOutCore.write('\n');
      for ix in range(len(inport['config'])):
        configs = inport['config'][ix];
        names = inport['name'][ix];
        for jx in range(len(configs)):
          if re.match(r'\d+-bit',configs[jx]):
            pass;
          elif configs[jx] == 'strobe':
            fpOutCore.write('initial %s = 1\'b0;\n' % names[jx]);
            fpOutCore.write('always @ (posedge i_clk)\n');
            fpOutCore.write('  if (i_rst)\n');
            fpOutCore.write('    %s = 1\'b0;\n' % names[jx]);
            fpOutCore.write('  else if (s_outport)\n');
            fpOutCore.write('    %s = (s_T == 8\'h%02X);\n' % (names[jx],ix));
            fpOutCore.write('  else\n');
            fpOutCore.write('    %s = 1\'b0;\n' % names[jx]);
            fpOutCore.write('\n');
          else:
            raise Exception('Unrecognized INPORT type: "%s"' % configs[jx]);
    else:
      fpOutCore.write('// no input ports\n');
  # instructions
  elif fillCommand == 'instructions':
    fpOutCore.write('initial begin\n');
    programBodyIx = 0;
    for ix in range(len(programBody)):
      if programBody[ix][0] == '-':
        fpOutCore.write('  // %s\n' % programBody[ix][2:]);
      else:
        fpOutCore.write('  s_opcodeMemory[\'h%X] = 9\'h%s; // %s\n' % (programBodyIx,programBody[ix][0:3],programBody[ix][4:]));
        programBodyIx = programBodyIx + 1;
    for ix in range(programBodyIx,instruction):
      fpOutCore.write('  s_opcodeMemory[\'h%X] = 9\'h000;\n' % ix);
    fpOutCore.write('end\n');
  # localparam
  elif fillCommand == 'localparam':
    fpOutCore.write('localparam C_PC_WIDTH                              = %4d;\n' % CeilLog2(instruction));
    fpOutCore.write('localparam C_RETURN_PTR_WIDTH                      = %4d;\n' % CeilLog2(return_stack));
    fpOutCore.write('localparam C_DATA_PTR_WIDTH                        = %4d;\n' % CeilLog2(data_stack));
    fpOutCore.write('localparam C_SMALL_RETURN_STACK_IMPLEMENTATION     =    1;\n');
    fpOutCore.write('localparam C_SMALL_DATA_STACK_IMPLEMENTATION       =    1;\n');
    fpOutCore.write('reg [8:0] s_opcodeMemory[%d:0];\n' % (instruction-1));
  # module
  elif fillCommand == 'module':
    if hdl == 'Verilog':
      fpOutCore.write('module %s(\n' % outCoreName);
      fpOutCore.write('  // synchronous reset and processor clock\n');
      fpOutCore.write('  input  wire           i_rst,\n');
      fpOutCore.write('  input  wire           i_clk');
      if inport['config']:
        for ix in range(len(inport['config'])):
          fpOutCore.write(',\n');
          fpOutCore.write('  // inport ports\n');
          configs = inport['config'][ix];
          names = inport['name'][ix];
          for jx in range(len(configs)):
            if (ix != 0) or (jx != 0):
              fpOutCore.write(',\n');
            if re.match(r'\d+-bit',configs[jx]):
              inports_have_bitsignals = True;
              a = re.findall(r'(\d+)',configs[jx]);
              portLength = int(a[0]);
              if portLength == 1:
                fpOutCore.write('  input  wire           %s' % names[jx]);
              elif portLength < 10:
                fpOutCore.write('  input  wire     [%d:0] %s' % (portLength-1,names[jx]));
              else:
                fpOutCore.write('  input  wire    [%d:0] %s' % (portLength-1,names[jx]));
            elif configs[jx] == 'strobe':
              fpOutCore.write('  output reg            %s' % names[jx]);
            else:
              raise Exception('Unrecognized INPORT type: "%s"' % configs[jx]);
      if outport['config']:
        for ix in range(len(outport['config'])):
          fpOutCore.write(',\n');
          fpOutCore.write('  // outport ports\n');
          configs = outport['config'][ix];
          names = outport['name'][ix];
          for jx in range(len(configs)):
            if (ix != 0) or (jx != 0):
              fpOutCore.write(',\n');
            if re.match(r'\d+-bit',configs[jx]):
              a = re.findall(r'(\d+)',configs[jx]);
              portLength = int(a[0]);
              if portLength == 1:
                fpOutCore.write('  output reg            %s' % names[jx]);
              elif portLength < 10:
                fpOutCore.write('  output reg      [%d:0] %s' % (portLength-1,names[jx]));
              else:
                fpOutCore.write('  output reg     [%d:0] %s' % (portLength-1,names[jx]));
            elif configs[jx] == 'strobe':
              fpOutCore.write('  output reg            %s' % names[jx]);
            else:
              raise Exception('Unrecognized INPORT type: "%s"' % configs[jx]);
      fpOutCore.write('\n');
      fpOutCore.write(');\n');
    if hdl == 'VHDL':
      raise Exception('VHDL not implemented');
  # outports
  elif fillCommand == 'outports':
    if outport['config']:
      for ix in range(len(outport['config'])):
        configs = outport['config'][ix];
        names = outport['name'][ix];
        for jx in range(len(configs)):
          if re.match(r'\d+-bit',configs[jx]):
            a = re.findall(r'(\d+)',configs[jx]);
            portLength = int(a[0]);
            fpOutCore.write('initial %s = %d\'h0;\n' % (names[jx],portLength));
            fpOutCore.write('always @ (posedge i_clk)\n');
            fpOutCore.write('  if (i_rst)\n');
            fpOutCore.write('    %s = %d\'h0;\n' % (names[jx],portLength));
            fpOutCore.write('  else if (s_outport && (s_T == 8\'h%02X))\n' % ix);
            fpOutCore.write('    %s = s_N[0+:%d];\n' % (names[jx],portLength));
            fpOutCore.write('  else\n');
            fpOutCore.write('    %s = %s;\n' % (names[jx],names[jx]));
            fpOutCore.write('\n');
          elif configs[jx] == 'strobe':
            fpOutCore.write('initial %s = 1\'b0;\n' % names[jx]);
            fpOutCore.write('always @ (posedge i_clk)\n');
            fpOutCore.write('  if (i_rst)\n');
            fpOutCore.write('    %s = 1\'b0;\n' % names[jx]);
            fpOutCore.write('  else if (s_outport)\n');
            fpOutCore.write('    %s = (s_T == 8\'h%02X);\n' % (names[jx],ix));
            fpOutCore.write('  else\n');
            fpOutCore.write('    %s = 1\'b0;\n' % names[jx]);
            fpOutCore.write('\n');
          else:
            raise Exception('Unrecognized INPORT type: "%s"' % configs[jx]);
    else:
      fpOutCore.write('// no output ports\n');
  # user_header
  elif fillCommand == 'user_header':
    for ix in range(len(user_header)):
      if hdl == 'Verilog':
        fpOutCore.write('// %s\n' % user_header[ix]);
      elif hdl == 'VHDL':
        fpOutCore.write('-- %s\n' % user_header[ix]);
      else:
        raise Exception('Unimplemented language %s' % hdl);
  # error
  else:
    print 'WARNING:  Unimplemented command ' + fillCommand;
