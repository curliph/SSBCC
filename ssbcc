#!/usr/bin/python

################################################################################
#
# Copyright 2012, Sinclair R.F., Inc.
#
# Build an SSBCC system.
#
################################################################################

import math
import os
import re
import sys
import tempfile

from ssbccUtil import *;
from ssbccConfig import SSBCCconfig;

################################################################################
#
# Surround the program with a try ... except clause
#
################################################################################

try:

  ################################################################################
  #
  # Parse the command line arguments
  #
  ################################################################################

  #
  # Construct the command-line argument list parser
  #

  import argparse
  argListParser = argparse.ArgumentParser(description='SSBCC system builder');
  argListParser.add_argument('-G', metavar='parameter_name=value', type=str, action='append', help='Override parameter value');
  argListParser.add_argument('-P', metavar='peripheral_name[="parameters"]', type=str, action='append', help='Add peripheral');
  argListParser.add_argument('-o', metavar='outCoreName', type=str, help='output core name');
  argListParser.add_argument('-q', action='store_true', help='quiet');
  argListParser.add_argument('--define-clog2', action='store_true', help='define clog2 instead of using built-in $clog2');
  argListParser.add_argument('--verilator-tracing-on', action='store_true', help='show all signals in verilator waveform files');
  argListParser.add_argument('filename', metavar='filename', type=file, help='SSBCC configuration file');
  argList = argListParser.parse_args();

  #
  # Set the command-line dependent configuration parameters.
  #

  config = SSBCCconfig();

  config.Set('define_clog2',argList.define_clog2);
  config.Set('verilator_tracing_on',argList.verilator_tracing_on);

  if argList.o:
    config.Set('outCoreName',argList.o);
  else:
    config.Set('outCoreName',os.path.splitext(os.path.basename(argList.filename.name))[0]);

  #
  # Read the configuration file.
  #

  ixLine = 0;
  bufLine = "";
  compiler = [];
  memories = dict(list=list(), type=list(), arch=list());
  user_header = list();
  for tmpLine in argList.filename:
    ixLine = ixLine + 1;
    # Merge continuation lines.
    bufLine += tmpLine;
    if bufLine[-2:] == '\\\n':
      bufLine = bufLine[:-2];
      continue;
    line = bufLine;
    bufLine = "";
    # Reject blank and comment lines
    if re.match(r'\s*(#.*)?$',line):
      pass;
    # ARCHITECTURE
    elif re.match(r'\s*ARCHITECTURE\b',line):
      if config.Exists('architecture'):
        raise SSBCCException('ARCHITECTURE already specified before line %d' % ixLine);
      cmd = re.findall(r'\s*ARCHITECTURE\s+(\S+)',line);
      if not cmd:
        raise SSBCCException('Malformed ARCHITECTURE configuration command on line %d: "%s"' % (ixLine,line[:-1],));
      config.Set('architecture',cmd[0]);
      corepath = os.path.join(sys.path[0],config.Get('architecture'));
      if not os.path.isdir(corepath):
        raise SSBCCException('Architecture "%s" does not exist at line %d' % (cmd,ixLine,));
      config.InsertPeripheralPath(os.path.join(corepath,'peripherals'));
      # TODO -- move these assignments into an object
      config.Set('data_width',8);
    # ASSEMBLY language for processor code
    elif re.match(r'\s*ASSEMBLY\b',line):
      cmd = re.findall(r'\s*ASSEMBLY\s+(\S.*)',line);
      compiler = ('asm',cmd[0],);
    # CONSTANTS
    elif re.match(r'\s*CONSTANT\b',line):
      if not config.Exists('architecture'):
        raise SSBCCException('"CONSTANT"s cannot be defined before the "ARCHITECTURE" is defined at line %d' % ixLine);
      cmd = re.findall(r'\s*CONSTANT\s+(C_\w+)\s+(\w+)\s*$',line);
      if not cmd:
        raise SSBCCException('Malformed "CONSTANT" configuration command on line %d: "%s"' % (ixLine,line[:-1],));
      cmd = cmd[0];
      config.AddConstant(cmd[0],cmd[1],ixLine);
    # DATA_STACK
    elif re.match(r'\s*DATA_STACK\b',line):
      if config.Exists('data_stack'):
        raise SSBCCException('DATA_STACK already defined before line %d' % ixLine);
      cmd = re.findall(r'\s*DATA_STACK\s+([1-9]\d*)',line);
      if not cmd:
        raise SSBCCException('Malformed "DATA_STACK" configuration command on line %d: "%s"' % (ixLine,line[:-1],));
      config.Set('data_stack',int(cmd[0]));
    # HDL
    elif re.match(r'\s*HDL\s',line):
      if config.Exists('hdl'):
        raise SSBCCException('HDL already specified before line %d' % ixLine);
      cmd = re.findall(r'\s*HDL\s+(\S+)\s*$', line);
      if not cmd:
        raise SSBCCException('Malformed "HDL" configuration command on line %d:  "%s"' % (ixLine,line[:-1],));
      config.Set('hdl',cmd[0]);
    # INPORT
    elif re.match(r'\s*INPORT\b',line):
      if not config.Exists('architecture'):
        raise SSBCCException('"INPORT"s cannot be defined before the "ARCHITECTURE" is defined at line %d' % ixLine);
      config.ProcessInport(ixLine,line);
    # INSTRUCTION
    elif re.match(r'\s*INSTRUCTION\b',line):
      if config.Exists('nInstructions'):
        raise SSBCCException('INSTRUCTION already specified before line %d' % ixLine);
      cmd = re.findall(r'\s*INSTRUCTION\s+([1-9]\d*)',line);
      if not cmd:
        raise SSBCCException('Malformed "INSTRUCTION" configuration command on line %d: "%s"' % (ixLine,line[:-1],));
      config.Set('nInstructions',int(cmd[0]));
      if config.Get('nInstructions') > 2**13:
        raise SSBCCException('Instruction space cannot exceed %d at line %d' % (2**13,ixLine,));
    # MEMORY
    elif re.match(r'\s*MEMORY\b',line):
      if not config.Exists('architecture'):
        raise SSBCCException('"MEMORY"s cannot be defined before the "ARCHITECTURE" is defined at line %d' % ixLine);
      # TODO -- make the maximum number of memories architecture dependent
      if len(memories['list']) >= 4:
        raise SSBCCException('Program is limited to 4 memories');
      cmd = re.findall(r'\s*MEMORY\s+(\S+)\s+(\S+)\s+(\S+)\s*$',line);
      if (not cmd) or (len(cmd[0]) != 3):
        raise SSBCCException('Malformed MEMORY configuration command on line %d: "%s"' % (ixLine,line[:-1],));
      cmd = cmd[0];
      memories['type'].append(cmd[0]);
      memories['list'].append(cmd[1]);
      memories['arch'].append(cmd[2]);
    # OUTPORT
    elif re.match(r'\s*OUTPORT\b',line):
      if not config.Exists('architecture'):
        raise SSBCCException('"OUTPORT"s cannot be defined before the "ARCHITECTURE" is defined at line %d' % ixLine);
      config.ProcessOutport(line,ixLine);
    # PARAMETER
    elif re.match(r'\s*PARAMETER\b',line):
      cmd = re.findall(r'\s*PARAMETER\s+(G_\w+)\s+(\S+)$',line);
      if (not cmd) or (len(cmd[0]) != 2):
        raise SSBCCException('Malformed PARAMETER configuration command on line %d: "%s"' % (ixLine,line[:-1],));
      cmd = cmd[0];
      config.AddParameter(cmd[0],cmd[1]);
    # PERIPHERAL
    elif re.match(r'\s*PERIPHERAL\b',line):
      if not config.Exists('architecture'):
        raise SSBCCException('"PERIPHERAL"s cannot be defined before the "ARCHITECTURE" is defined at line %d' % ixLine);
      config.ProcessPeripheral(ixLine,line);
    # PORTCOMMENT
    elif re.match(r'\s*PORTCOMMENT\b',line):
      cmd = re.findall(r'\s*PORTCOMMENT\s+(.*)',line[:-1]);
      config.AddIO(cmd[0],0,'comment');
    # RETURN_STACK
    elif re.match(r'\s*RETURN_STACK\b',line):
      if config.Exists('return_stack'):
        raise SSBCCException('RETURN_STACK already specified before line %d' % ixLine);
      cmd = re.findall(r'\s*RETURN_STACK\s+([1-9]\d*)',line);
      if not cmd:
        raise SSBCCException('Malformed "RETURN_STACK" configuration command on line %d: "%s"' % (ixLine,line[:-1],));
      config.Set('return_stack',int(cmd[0]));
    # USER_HEADER
    elif re.match(r'\s*USER_HEADER\b',line):
      user_header_done = False;
      for line in argList.filename:
        ixLine = ixLine + 1;
        if re.match(r'\s*END_USER_HEADER\s',line):
          user_header_done = True;
          break;
        user_header.append(line[0:-1]);
      if not user_header_done:
        raise SSBCCException('No "END_USER_HEADER" found for "USER_HEADER"');
    # error
    else:
      raise SSBCCException('Unrecognized configuration command on line %d: "%s"' % (ixLine,line[:-1],));
  argList.filename.close();

  #
  # Incorporate command-line specified parameters values
  #

  if argList.G:
    for parameter in argList.G:
      if not re.match(r'G_\w+=\S+$',parameter):
        raise SSBCCException('Malformed parameter specification: "%s"' % parameter);
      cmd = re.findall(r'(G_\w+)=(\S+)',parameter);
      cmd = cmd[0];
      config.OverrideParameter(cmd[0],cmd[1]);

  #
  # Append peripherals from command-line.
  #

  if argList.P:
    for peripheral in argList.P:
      config.ProcessPeripheral(-1,'PERIPHERAL '+peripheral);

  #
  # end-of-file processing
  #

  if not config.Exists('architecture'):
    raise SSBCCException('Required ARCHITECTURE configuration command missing');
  if not config.Exists('data_stack'):
    raise SSBCCException('Required DATA_STACK configuration command missing');
  if not config.Exists('hdl'):
    raise SSBCCException('Required HDL configuration command missing');
  if not config.Exists('nInstructions'):
    raise SSBCCException('Required INSTRUCTION configuration command missing');
  if not config.Exists('return_stack'):
    raise SSBCCException('Required RETURN_STACK configuration command missing');

  # Compute the memory bank indices.
  ixRAM = 0;
  ixROM = 3;
  memories['bank'] = list();
  memories['length'] = list();
  memories['body'] = list();
  for memType in memories['type']:
    memories['bank'].append(None);
    memories['length'].append(None);
    memories['body'].append(None);

  ################################################################################
  #
  # Compile the processor code and read the tables it generated.
  #
  ################################################################################

  # Generate peripheral libraries (if any).
  for ix in range(len(config.peripheral)):
    config.peripheral[ix].GenAssembly(config);

  # Compute the file name to store the assembler output
  assemblerOutput = os.path.splitext(argList.filename.name)[0]+'.9x8-meta'

  # Compute the command to invoke the compiler.
  cmd = os.path.join(corepath, compiler[0]);
  for name in config.constants:
    cmd += (' -C %s=%s' % (name,config.constants[name],));
  for ix in range(len(config.parameters)):
    cmd += (' -G %s' % config.parameters[ix][0]);
  for ix in range(len(config.inports)):
    cmd += (' -I %s=%d' % (config.inports[ix][0],ix));
  for ix in range(len(config.outports)):
    cmd += (' -O %s=%d' % (config.outports[ix][0],ix));
  for ix in range(len(memories['list'])):
    cmd += (' -S %s=%d' % (memories['list'][ix],eval(memories['arch'][ix])));
  cmd += ' -o ' + assemblerOutput;
  for stack_name in ('data_stack','return_stack',):
    cmd += ' -s %s=%d' % (stack_name,config.config[stack_name],);
  cmd += ' -L %s/%s' % (sys.path[0], 'lib/9x8');
  cmd += ' ' + compiler[1];

  # Invoke the compiler and exit if it failed.
  if not argList.q:
    print 'Invoking the assember with the following command:  ' + cmd;
  cmdStatus = os.system(cmd);
  if cmdStatus != 0:
    raise SSBCCException('Running the assembler');

  # Read the assembler output tables.
  fpAssemberOutput = open(assemblerOutput,'r');
  ixLine = 0;
  programBody = list();
  programBodyLength = 0;
  for line in fpAssemberOutput:
    ixLine = ixLine + 1;
    # blank line
    if re.match('^\s*$',line):
      continue;
    # memory type, name, index, and length
    elif re.match(':memory',line):
      cmd = re.findall(':memory (\S+) (\S+) (\S+) (\S+)',line);
      cmd = cmd[0];
      if cmd[1] not in memories['list']:
        raise SSBCCException('%s "%s" not declared %s' % (cmd[0],cmd[1],argList.filename,));
      ixMem = memories['list'].index(cmd[1]);
      if cmd[0] != memories['type'][ixMem]:
        raise SSBCCException('Type of memory "%s" is inconsistent' % cmd[1]);
      if int(cmd[2]) != ixMem:
        raise Exception('Program Bug:  Memory index for "%s" from assembler does not match commanded index' % cmd[1]);
      if int(cmd[3]) > eval(memories['arch'][ixMem]):
        raise SSBCCException('Length of memory "%s" is %s which exceeds limit of %d' % (cmd[1],cmd[3],eval(memories['arch'][ixMem]),));
      memories['bank'][ixMem] = int(cmd[2]);
      memories['length'][ixMem] = cmd[3];
      memoryBody = list();
      for line in fpAssemberOutput:
        ixLine = ixLine + 1;
        if len(line) <= 1:
          memories['body'][ixMem] = memoryBody;
          break;
        memoryBody.append(line)
    # program .main, optional .interrupt, and length
    elif re.match(':program',line):
      cmd = re.findall(':program (\d+) (\S+) (\d+)',line);
      mainStart = int(cmd[0][0]);
      if cmd[0][1] == '[]':
        interruptStart = -1;
      else:
        interruptStart = int(cmd[0][1]);
      mainLength = int(cmd[0][2]);
      for line in fpAssemberOutput:
        ixLine = ixLine + 1;
        if len(line) <= 1:
          break;
        programBody.append(line[0:-1]);
        if line[0] != '-':
          programBodyLength = programBodyLength + 1;
      if programBodyLength != mainLength:
        raise SSBCCException('Program Bug:  program length doesn\'t match declared length');
      if programBodyLength > config.Get('nInstructions'):
        raise SSBCCException('Program body length = %d is longer than the allocated instruction table = %d' % (programBodyLength,config.Get('nInstructions'),));
    else:
      raise Exception('Program Bug:  Unrecognized line at %s:%d :  "%s"' % (fpAssemberOutput.filename,ixLine,line[:-1],));

  ################################################################################
  #
  # Ensure the processor has been consistently defined.
  #
  ################################################################################

  # Ensure all desired memories are used.
  for ixMem in range(len(memories['list'])):
    if not memories['length'][ixMem]:
      raise SSBCCException('Memory "%s" not used in program' % memories['list'][ixMem]);

  ################################################################################
  #
  # Generate the processor core.
  #
  ################################################################################

  #
  # Access the language-specific core generator and core.
  #

  if config.Get('hdl') == 'Verilog':
    ssbccGenFile = 'ssbccGenVerilog.py';
  elif config.Get('hdl') == 'VHDL':
    ssbccGenFile = 'ssbccGenVHDL.py';
  else:
    raise SSBCCException('Unrecognized hdl = "%s"' % config.Get('hdl'));

  ssbccGenFile = os.path.join(corepath,ssbccGenFile);
  if not os.path.isfile(ssbccGenFile):
    raise SSBCCException('Core generator "%s" missing for hdl = "%s"' % (ssbccGenFile,config.Get('hdl'),));
  execfile(ssbccGenFile);

  rawCoreName = os.path.join(corepath,genCoreName());
  if not os.path.isfile(rawCoreName):
    raise SSBCCException('Core "%s% missing for hdl = "%s"' % (rawCoreName,config.Get('hdl'),));
  fpRawCore = open(rawCoreName,'r');

  outName = genOutName(config.Get('outCoreName'));
  fpOutCore = open(outName,'w');

  #
  # Loop through the core, copying or filling in the file as required.
  #

  for line in fpRawCore:
    if not re.match('..@SSBCC@',line):
      fpOutCore.write(line);
      continue;
    fillCommand = re.findall('..@SSBCC@\s+(\S+)',line)[0];
    # functions and tasks
    if fillCommand == "functions":
      genFunctions(fpOutCore,config);
    # inports
    elif fillCommand == 'inports':
      genInports(fpOutCore,config);
    # instructions
    elif fillCommand == 'instructions':
      genInstructions(fpOutCore,programBody,config);
    # localparam
    elif fillCommand == 'localparam':
      genLocalParam(fpOutCore,config);
    # memory
    elif fillCommand == 'memory':
      genMemory(fpOutCore,memories);
    # module
    elif fillCommand == 'module':
      genModule(fpOutCore,config);
    # outports
    elif fillCommand == 'outports':
      genOutports(fpOutCore,config);
    # peripherals
    elif fillCommand == 'peripherals':
      if config.peripheral:
        fpOutCore.write('//\n// Peripherals\n//\n');
      for ix in range(len(config.peripheral)):
        fpOutCore.write('\n');
        config.peripheral[ix].GenHDL(fpOutCore,config);
    # additional signals
    elif fillCommand == 'signals':
      genSignals(fpOutCore,config);
    # user_header
    elif fillCommand == 'user_header':
      genUserHeader(fpOutCore,user_header);
    # Verilator tracing on/off
    elif fillCommand == "verilator_tracing":
      if config.Get('verilator_tracing_on'):
        fpOutCore.write('/* verilator tracing_on */\n');
      else:
        fpOutCore.write('/* verilator tracing_off */\n');
    # error
    else:
      print 'WARNING:  Unimplemented command ' + fillCommand;

################################################################################
#
# Terminating except clause
#
################################################################################

except SSBCCException, msg:
  print >> sys.stderr, 'FATAL ERROR:  ' + str(msg);
  exit(1);
