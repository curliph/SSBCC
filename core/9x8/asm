#!/usr/bin/python

################################################################################
#
# Copyright 2012, Sinclair R.F., Inc.
#
# Assembler for SSBCC 9x8 processor
#
################################################################################

# global modules
import argparse
import re

# User defined modules
import asmDef
from fileDirectiveBlockIterator import fileDirectiveBlockIterator

################################################################################
#
# Stage 1:  Parse the files.
#
# Read the entire file, doing the following while reading the file:
# - Store the raw content of each line or group of lines for output to the
#   assembled memory initialization.
#   Note: A group of lines consists the comment lines preceding a macro
#         directive and the body of the macro directive.
#   Note:  The macro directives are
#           .constant
#           .function
#           .include
#           .interrupt (variant of ".function" macro)
#           .macro
#           .main
#           .memory
#           .variable
# - Convert group of lines into an array of the raw tokens.
# - For each array of tokens (which must begin with one of the macro directives)
#   update the assembler dictionaries as required.  A malformed macro array is
#   an error and immediately terminates the parser.  Add a report of the macro
#   to the group of lines.  No more processing is done for a macro array.
# - Accumulate the arrays of tokens comprising the body of a ".function" or
#   ".main" body.
# - At the end of a ".function" or ".main" body, do the following:
#   - Issue an error if a ".function" body does not end in a ".jump" or
#     ".return".  Issue an error if a ".main" body does not end in a ".jump".
#     Note:  ".interrupt" bodies prepend a "ena" instruction before the
#            ".return" macro.
#   - Perform full substitution for all user-defined macros.
#   - Perform full substitution for ".fetch", ".fetchindexed", ".store", and
#     ".storeindexed" pre-defined macros.
#   - Perform preliminary substitution for ".call" and ".callc" pre-defeined
#     macros and add the call index to the ".function" definition (to identify
#     which functions are actually required by the program).
#   - Make a list of jump targets within the ".function" or ".main" body.
#   - Perform preliminary substitution for ".jump" and ".jumpc" pre-defined
#     macros.  Issue an error if the jump target is not defined within the body.
#   Note: At this point the space required for the function or main program
#     should be fully defined.
#   - Compute the offset of each jump target within the ".function" or ".main"
#     body.
#
################################################################################

#
# Stage 1 processing functions
#

inputGroups = list();
def Stage1(fp,ad):
  global inputGroups
  filename=fp.name;
  inputGroups.append(dict(filename=filename));
  fdbi = fileDirectiveBlockIterator(fp,ad.directives['list']);
  for bl in fdbi:
    startLine = bl[0];
    body = bl[1:];
    tokens=asmDef.TokenList(filename,startLine,body,ad);
    if tokens[0]['value'] in ad.directives['list']:
      tokens[0]['type']='directive';
    else:
      raise Exception('Program bug:  %s(%d)' % (filename,startLine));
    inputGroups.append(dict(startLine=startLine, body=body, rawTokens=tokens));

################################################################################
#
# Stage 2:  Perform the following consistency checks.
#
# - Ensure a ".main" body was defined.
# - If interrupts are enabled for the processor, ensure a single ".interrupt"
#   function was defined.
# - If interrupts are not enabled and an ".interrupt" was defined, then issue a
#   warning message.
# - Ensure all required ".function"s are defined.
#
################################################################################

################################################################################
#
# Stage 3:  Compute addresses.
#
# Compute the addresses for the ".main" and required ".function" bodies as
# follows:
# - Set the function address to 0.
# - If interrupts are enabled, then add 4 to the function address.
# - Set the start address of the main program to the current function address,
#   compute the addresses of all jump targets within the ".main" body, and then
#   add the length of the ".main" body to the function address.
# - Loop through the ".function" list in the order in which the functions were
#   defined and do the following:
#   - If the function was not used, then disabled its body.
#   - Otherwise, set the start address of the ".function" to the current
#     function address, compute the addresses of all jump targets within the
#     ".function" body, and add then length of the ".function" body to the
#     function address.
# - If then total program length exceedes the allowable program length, then
#   issue an error.
# - Loop through the ".main" body and ".function" bodies, setting the addresses
#   for all the ".call" and ".callc" macros.
#
################################################################################

################################################################################
#
# Stage 4:  Emit the program
#
# Do the following:
# - If interrupts are enabled, then set the first 4 instructions to be a "dis"
#   and a ".jump" instruction to the ".interrupt" function.
# - Write the instructions for the ".main" body.
# - Loop through the ".function" list in the order in which they were defined
#   and write their instructions.
# - Print the memory and instruction usage statistics.
#
################################################################################

################################################################################
#
# The main loop:
#
# - Process the command line arguments.
#
################################################################################

#
# Construct the command-line argument list parser
#

argListParser = argparse.ArgumentParser(description='SSBCC 9x8 assembler');
argListParser.add_argument('filename', metavar='filename', nargs='+', type=file, help='required list of files');
argList = argListParser.parse_args();

# Construct the keyword parser
from asmDef_9x8 import asmDef_9x8
ad = asmDef_9x8();

# Loop through the optional libraries and then the required files for the
# "Stage 1" parsing.
for fp in argList.filename:
  Stage1(fp,ad);

for ig in inputGroups:
  if 'filename' in ig:
    print ig['filename'];
  else:
    for tk in ig['rawTokens']:
      print tk;
    print
