#!/usr/bin/python

################################################################################
#
# Copyright 2012, Sinclair R.F., Inc.
#
# Assembler for SSBCC 9x8 processor
#
################################################################################

# global modules
import argparse
import re

# User defined modules
import asmDef

################################################################################
#
# Stage 1:  Parse the files.
#
# Read the entire file, doing the following while reading the file:
# - Store the raw content of each line or group of lines for output to the
#   assembled memory initialization.
#   Note: A group of lines consists the comment lines preceding a directive and
#         the body of the directive.
# - Convert group of lines into an array of the raw tokens.
# - Check the integrity of the bodies defined by the list of raw tokens.
# - For each array of raw tokens, incorporate already-defined symbols and update
#   the assembler dictionaries.
#   Note: At this point the space required for the function or main program
#     is fully computed.
#
################################################################################

#
# Stage 1 processing functions
#

inputGroups = list();
def Stage1(fdbi,ad):
  global inputGroups
  for bl in fdbi:
    filename = bl[0];
    startLine = bl[1];
    body = bl[2:];
    if re.match(r'\s*\.include\s',bl[-1]):
      inputGroups.append(dict(filename=filename, startLine=startLine, body=body));
    else:
      rawTokens = asmDef.TokenList(filename,startLine,body,ad);
      ad.CheckRawTokens(filename,rawTokens);
      ad.FillRawTokens(filename,rawTokens);
      inputGroups.append(dict(filename=filename, startLine=startLine, body=body, rawTokens=rawTokens));
#  inputGroups.CheckAllDefined();

################################################################################
#
# Stage 2:  Perform the following consistency checks.
#
# - If interrupts are enabled for the processor, ensure a single ".interrupt"
#   function was defined.
# - If interrupts are not enabled and an ".interrupt" was defined, then issue a
#   warning message.
# - Ensure all required ".function"s are defined.
#
################################################################################

################################################################################
#
# Stage 3:  Compute addresses.
#
# Compute the addresses for the ".main" and required ".function" bodies as
# follows:
# - Set the function address to 0.
# - If interrupts are enabled, then add 4 to the function address.
# - Set the start address of the main program to the current function address,
#   compute the addresses of all jump targets within the ".main" body, and then
#   add the length of the ".main" body to the function address.
# - Loop through the ".function" list in the order in which the functions were
#   defined and do the following:
#   - If the function was not used, then disabled its body.
#   - Otherwise, set the start address of the ".function" to the current
#     function address, compute the addresses of all jump targets within the
#     ".function" body, and add then length of the ".function" body to the
#     function address.
# - If then total program length exceedes the allowable program length, then
#   issue an error.
# - Loop through the ".main" body and ".function" bodies, setting the addresses
#   for all the ".call" and ".callc" macros.
#
################################################################################

################################################################################
#
# Stage 4:  Emit the program
#
# Do the following:
# - If interrupts are enabled, then set the first 4 instructions to be a "dis"
#   and a ".jump" instruction to the ".interrupt" function.
# - Write the instructions for the ".main" body.
# - Loop through the ".function" list in the order in which they were defined
#   and write their instructions.
# - Print the memory and instruction usage statistics.
#
################################################################################

################################################################################
#
# The main loop:
#
# - Process the command line arguments.
#
################################################################################

#
# Construct the command-line argument list parser
#

argListParser = argparse.ArgumentParser(description='SSBCC 9x8 assembler');
argListParser.add_argument('filename', metavar='filename', nargs='+', type=file, help='required list of files');
argList = argListParser.parse_args();

# Construct the keyword parser
from asmDef_9x8 import asmDef_9x8
ad = asmDef_9x8();

# Construct the iterator that loops through the code bodies.
import fileBodyIterator
fdbi = fileBodyIterator.fileBodyIterator(argList.filename,ad.directives['list']);

# "Stage 1" parsing.
Stage1(fdbi,ad);

# diagnostic
if False:
  for ig in inputGroups:
    print 'filename = "%s", startLine = %d' % (ig['filename'], ig['startLine']);
    if 'rawTokens' not in ig:
      print ig['body'][-1];
    else:
      for tk in ig['rawTokens']:
        print tk;
    print

# diagnostic
if True:
  main = ad.Main();
  print '.main, length=%d ' % main['length'];
  for token in main['tokens']:
    print token;
  print
  interrupt = ad.Interrupt();
  if interrupt:
    print '.interrupt, length=%d' % interrupt['length'];
    for token in interrupt:
      print token;
    print
  symbols = ad.Symbols();
  for ix in range(len(symbols['list'])):
    print 'symbol %s: type=%s, length=%d' % (symbols['list'][ix], symbols['type'][ix], symbols['length'][ix])
    for token in symbols['tokens'][ix]:
      print token;
    print
