<!-- Copyright 2012, Sinclair R.F., Inc. -->
<html>
<title>
9-bit opcode, 8-bit data stack-based micro controller
</title>
<body>
<b>9-bit Opcode, 8-bit Data, Stack-Based Micro Controller</b><br/>
Copyright 2012, Sinclair R.F., Inc.<br/><br/>
This document describes the 9-bit opcode, 8-bit data, stack-based
  microcontroller.
<h1>Directory Contents</h1>
  This directory contains the assembler and the Verilog and VHDL templates for
    the processor.  While the assember can be run by itself, it is more
    typically run within the "<tt>../../ssbcc</tt>" script as part of making a
    compute computer core.<br/><br/>
  The "<tt>core.v</tt>" and "<tt>core.vhd</tt>" files in this directory are not
    complete modules.  They cannot be compiled.<br/><br/>
<h1>Introduction</h1>
  This processor is a minimalist FPGA-based microcontroller.  It&nbsp;provides
    8-bit data manipulation operations and function calls.  There are no
    condition registers as the results of tests are on the data stack.  The
    instruction space, data stack size, return stack size, and existence and
    sizes of RAMs and ROMs are controlled by a configuration file so that the
    processor can be sized for the problem at hand.  The configuration file also
    describes the input and output ports and include 0&nbsp; to&nbsp;8 bit port
    widths and strobes.  A&nbsp;complete processor can be implemented using just
    the configuration file and the assembly file.<br/><br/>
  A&nbsp;9-bit opcode was chosen because (1)&nbsp;it works well with Altera,
    Lattice, and Xilinx SRAM widths and (2)&nbsp;it allows pushing 8-bit data
    onto the stack with a single instruction.<br/><br/>
  An&nbsp;8-bit data width was chosen because that's a practical minimal
    size.  It&nbsp;is also common to many hardware interfaces such as I2C
    devices.<br/><br/>
  The machine has single-cycle instruction execution for all
    instructions.  However, some operations, such as a jump, require pushing the
    8 lsb of the target address onto the stack in one instruction, executing the
    jump with the remaining 5 msb of the target address, and then a <tt>nop</tt>
    during the following instruction.<br/><br/>
  Only one data stack shift can be achieved per instruction cycle.  This means
    that all operations that consume the top two elements of the stack, such as
    a store instruction, can only remove one element from the stack and must be
    immediately followed by a "<tt>drop</tt>" instruction to remove what had
    been the second element on the data stack.<br/><br/>
  This architecture accommodates up to a 13-bit instruction address space by
    first pushing the 8 least significant bits of the destination address onto
    the stack and then encoding the 5&nbsp;most significant bits in the jump
    instruction.  This is the largest practicable instruction address width
    because (1)&nbsp;one bit of the opcode is required to indicate pushing an
    8-bit value onto the stack, (2)&nbsp;one bit of the remaining 8 bits is
    required to indicate a jump instructions, (3)&nbsp;one bit is required to
    indicate whether the jump is always performed or is conditionally performed,
    and (4)&nbsp;one more bit is required to indicate whether the jump is a jump
    or a call.  This consumes 4&nbsp;bits and leaves 5&nbsp;bits of additional
    address space for the jump instruction.<br/><br/>
  This architecture also supports 0 to 8&nbsp;pages of RAM and ROM with a
    combined limit of 8&nbsp;pages.  Each page of RAM or ROM can hold up to
    256&nbsp;bytes of data.<br/><br/>
<h1>Design</h1>
  This section describes things the processor does not do and what is required
    in code to work around these restrictions:<br/><br/>
  <ul>
    <li>Data Stack Operations:<br/><br/>
      While the large SRAMs and distributed memory can be dual port, minimizing
        the FPGA resources required for the processor means that the stack
        memory and the program ROM frequently share a single SRAM.  That
        requirement prohibits using dual port memory operations for the stack.
        Also, the requirement that all instructions be single-cycle means that
        only one stack operation can be performed per clock cycle.<br/><br/>
      The large SRAM on the FPGAs can have registers for their input addresses
        and values and registers for their output data.  These registers are
        used to extract the fastests speed possible from the memory.  While it
        is possible to design the stack operations to avoid these registers,
        that isn't always what's desired.  This however impacts how stack
        operations are performed.<br/><br/>
      Implementing the "<tt>rot</tt>" instruction, i.e., if
        "<tt>1&nbsp;2&nbsp;3</tt>" are the top 3 elements of the data stack with
        "<tt>3</tt>" on the top of the stacks, then "<tt>rot</tt>" changes the
        stack to "<tt>2&nbsp;3&nbsp;1</tt>", would seem to require immediate
        access to the third element on the stack.  However, the instruction
        sequence "<tt>&gt;r&nbsp;swap&nbsp;r&gt;swap</tt>" has the same effect
        and only requires access to the top two elements of the data stack, but
        does require that the return stack be implemented.<br/><br/>
      This means that only the first two elements of the stack need to be
        accessible.  That is "<tt>S</tt>" must be implemented in a registers.
        The question then is, can "<tt>N</tt>" be implemented as the output of
        the data stack with the input address register and output data register,
        or must it also be implemented as a separate register?  Suppose that the
        data stack address or the top element in the data stack SRAM changes
        during clock cycle&nbsp;<em>n</em>.  Then the new value for "<tt>N</tt>"
        will not be available until clock cycle&nbsp;<em>n</em>+2.  This means
        that the preceding implementation for the "<tt>rot</tt>" operation would
        have to be implemented as
        "<tt>&gt;r&nbsp;nop&nbsp;swap&nbsp;nop&nbsp;r&gt;nop&nbsp;swap</tt>".
        This substantially impairs the efficiency of the program, which means
        that the value of "<tt>N</tt>" must be stored in a register separate
        from the SRAM register.<br/><br/>
      Then, in order to implement the "<tt>drop</tt>" instruction, the output of
        the SRAM must be the third value on the stack.  In&nbsp;order to
        immediately follow one "<tt>drop</tt>" instruction with another, the
        output of the SRAM must immediately change to the next previous value on
        the data stack.  I.e., if <em>SP</em> is the stack pointer, then
        <em>SP</em>-1 points to the memory location where "<tt>N</tt>" would be
        stored, <em>SP</em>-2 points to the third value on the stack, etc., then
        the input address to the stack pointer memory must be <em>SP</em>-3.
        When the first "<tt>drop</tt>" instruction is performed, the contents of
        "<tt>N</tt>" will be stored by the "<tt>T</tt>" register, the output of
        the SRAM register will be stored by the "<tt>N</tt>" register, the
        output register of the SRAM will be enabled to store the unregister
        output of the internal memory and will have the new value for the third
        element on the stack.  Simultaneously, the input address register for
        the SRAM will latch the new value of <em>SP</em>-3 so that the internal,
        unregistered output of the SRAM will be the new fourth element on the
        stack.  This will allow "<tt>drop</tt>" instructions to be issued
        sequentially with no intermiediate "<tt>nop</tt>"
        instructions.<br/><br/>
      A&nbsp;problem with these scheme occurs if a "<tt>drop</tt>" or
        "<tt>nip</tt>" instruction is preceded by a write instruction to the
        stack.  Suppose the top 3 values in the data stack are
        "<tt>1&nbsp;2&nbsp;3</tt>" and the instruction sequence
        "<tt>4&nbsp;nip</tt>" is performed during clock cycle&nbps;<em>n</em>.
        At the end of clock cycle <em>n</em>, the input data and address
        registers for the SRAM will be "<tt>2</tt>" and the new value for
        <em>SP</em>-2.  At&nbsp;the same time, the output register will still
        have the value&nbsp;"<tt>1</tt>" because that is the value that had been
        pointed to by the previously registered input address.  In&nbsp;order
        for the subsequent "<tt>nip</tt>" instruction to work properly, the
        output register should have the value&nbsp;"<tt>2</tt>".  Since the
        memory write is actually done during clock cycle <em>n</em>+1, there
        really isn't a practical way to have the SRAM output register have the
        correct value at the end of clock cycle&nbsp;<em>n</em>.  This defect
        can be corrected by requiring a "<tt>nop</tt>" instruction between the
        two instructions, swapping the order of the push and "<tt>nip</tt>"
        instructions and replacing the "<tt>nip</tt>" instruction with a
        "<tt>drop</tt>" instruction (if the "<tt>nip</tt>" instruction is not
        the target of a jump), or by adding a third data stack register.  None
        of these options is really attractive, however requiring users to
        remember to add "<tt>nop</tt>" instructions is the least attractive, so
        an additional, third data stack register is required.<br/><br/>
      Now, if "<tt>0&nbsp;1&nbsp;2&nbsp;3</tt>" are the values in the top of the
        data stack and the instruction sequence "<tt>4&nbsp;nip</tt>" is
        started during clock cycle&nbps;<em>n</em>, then at then end of clock
        cycle <em>n</em> the three data stack registers will be "<tt>2</tt>",
        "<tt>3</tt>", and "<tt>4</tt>", the input data and address registers to
        the SRAM will be "<tt>1</tt>" and <em>SP-3</em> respectively. and the
        contents of the SRAM output register will be invalid.  At&nbsp;the end
        of clock cycle <em>n</em>+1 the values of the "<tt>T</tt>" and
        "<tt>N</tt>" will be "<tt>4</tt>" and "<tt>2</tt>" respectively, the
        third data stack register will be invalid (since there is no good value
        to store in it), and the SRAM output register will have the new contents
        for the third data stack register.<br/><br/>
      For the following, let "<tt>T</tt>", "<tt>N</tt>", and "<tt>I</tt>" be the
        registers for the top of the stack, the next element on the stack, the
        intermediate register and let "<tt>R</tt>" be the output register of the
        SRAM.  The data stack manipulation must be such that "<tt>T</tt>" and
        "<tt>N</tt>" are always value.  Then, in order for a "<tt>drop</tt>" or
        "<tt>nip</tt>" instruction to opertate successfully, either "<tt>I</tt>"
        or "<tt>R</tt>" must have the third value on the stack and, if
        "<tt>R</tt>" does not already have the fourth value on the stack, it
        must do so by the end of the next clock cycle.<br/><br/>
      Supposed the top 4 elements on the stack are
        "<tt>0&nbsp;1&nbsp;2&nbsp;3</tt> and these are stored in the registers
        "<tt>R</tt>", "<tt>I</tt>", "<tt>N</tt>", and "<tt>T</tt>" respectively.
        Then the instruction sequence "<tt>4&nbsp;nip</tt>" started on clock
        cycle&nbsp;<em>n</em> will have the following effects.  At&nbsp; the end
        of clock cycle&nbsp<em>n</em>, the registers "<tt>T</tt>", "<tt>N</tt>",
        and "<tt>I</tt>" will be valid and have the values "<tt>4</tt>",
        "<tt>3</tt>", and "<tt>2</tt>" respectively, the SRAM input data and
        address registers will have the values "<tt>1</tt>" and <em>SP</em>-3
        respectively, and the SRAM output register will have the value
        "<tt>0</tt>", which is not valid.  After the "<tt>nip</tt>" instruction,
        at&nbsp;the end of clock cycle&nbsp;<em>n</em>+1, the "<tt>T</tt>" will
        be unchanged at "<tt>4</tt>" and will be valid; the "<tt>N</tt>" will
        have taken its value from "<tt>I</tt>", which had been valid, and will
        be "<tt>2</tt>", the "<tt>I</tt>" register will not have a valid value,
        and the "<tt>R</tt>" register will have the value "<tt>1</tt>" if the
        SRAM had been configured for write-through operation, which will be the
        valid valud for the third element on the stack as is required since the
        value of "<tt>I</tt>" is not valid.  At&nbsp;the same time, the input
        address register for the SRAM must be the new value of
        <em>SP</em>-3.<br/><br/>
      </li>
    <li>JUMP and JUMPC:<br/><br/>
      The large SRAM on the FPGAs can have registers for their input addresses
        and registers for their output data.  These registers are used to extract
        the fastest speed possible from the memory.  While it is possible to
        design the processor ROM to avoid these registers, that isn't always
        what's desired.  This however impacts how jump instructions are
        performed.<br/><br/>
      Specifically, if a jump instruction changes the program counter during
        cycle <em>n</em>, then the new input address is registered at the end of that
        clock cycle and the corresponding data is registered at the end of the
        next clock cycle, i.e., the new opcode is available at the end of cycle
        <em>n</em>+1.  That is, the new opcode isn't performed by the core until
        cycle&nbsp;<em>n</em>+2.<br/><br/>
      This means that JUMP and JUMPC instructions must be followed by a TBD
        instruction.<br/><br/>
      TODO -- should "TBD" be a "nop", a "drop", or push the PC onto the return
        stack?<br/><br/>
      </li>
    </ul>
<h1>OPCODES</h1>
  This section documents the opcodes.<br/><br/>
  Alphabetic listing:
    <a href="#&">&amp;</a>,
    <a href="#+">+</a>,
    <a href="#-">-</a>,
    <a href="#-1<>">-1&lt;&gt;</a>,
    <a href="#-1=">-1=</a>,
    <a href='#+ss'>+ss</a>,
    <a href='#+su'>+su</a>,
    <a href='#+us'>+us</a>,
    <a href='#+uu'>+uu</a>,
    <a href='#-ss'>-ss</a>,
    <a href='#-su'>-su</a>,
    <a href='#-us'>-us</a>,
    <a href='#-uu'>-uu</a>,
    <a href="#0<>">0&lt;&gt;</a>,
    <a href="#0=">0=</a>,
    <a href="#0>>">0&gt;&gt;</a>,
    <a href="#1>>">1&gt;&gt;</a>,
    <a href="#<<0">&lt;&lt;0</a>,
    <a href="#<<1">&lt;&lt;1</a>,
    <a href="#<<msb">&lt;&lt;msb</a>,
    <a href="#>r">&gt;r</a>,
    <a href="#FE=">FE=</a>,
    <a href="#FF=">FF=</a>,
    <a href="#^">^</a>,
    <a href="#call">call</a>,
    <a href="#callc">callc</a>,
    <a href="#dis">dis</a>,
    <a href="#drop">drop</a>,
    <a href="#dup">dup</a>,
    <a href="#ena">ena</a>,
    <a href="#fetch">fetch</a>,
    <a href="#inport">inport</a>,
    <a href="#jump">jump</a>,
    <a href="#jumpc">jumpc</a>,
    <a href="#lsb>>">lsb&gt;&gt;</a>,
    <a href="#msb>>">msb&gt;&gt;</a>,
    <a href="#nip">nip</a>,
    <a href="#nop">nop</a>,
    <a href="#or">or</a>,
    <a href="#outport">outport</a>,
    <a href="#over">over</a>,
    <a href="#push">push</a>,
    <a href="#r>">r&gt;</a>,
    <a href="#r@">r@</a>,
    <a href="#return">return</a>,
    <a href="#store">store</a>,
    <a href="#swap">swap</a>
    <br/><br/>
  <h2><a name="opcode_mapping">Opcode Mapping</a></h2>
    <table>
    <tr>
      <th align="left">Opcode&nbsp;&nbsp;&nbsp;</th>
        <th>8</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3&nbsp;&nbsp;&nbsp;</th><th>2</th><th>1</th><th>0&nbsp;&nbsp;&nbsp;</th>
        <th align="left">Description</th>
        </tr>
      <th align="left"><a href="#nop">nop</a></th>
        <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
        <td align="left">no operation</td>
        </tr>
      <th align="left"><a href="#<<0">&lt;&lt;0</a></th>
        <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td>
        <td align="left">left shift 1 bit and bring in a 0</td>
        </tr>
      <th align="left"><a href="#<<1">&lt;&lt;1</a></th>
        <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td>
        <td align="left">left shift 1 bit and bring in a 1</td>
        </tr>
      <th align="left"><a href="#<<msb">&lt;&lt;msb</a></th>
        <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td>
        <td align="left">left shift 1 bit and rotate the msb into the lsb</td>
        </tr>
      <th align="left"><a href="#0>>">0&gt;&gt;</a></th>
        <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td>
        <td align="left">right shift 1 bit and bring in a 0</td>
        </tr>
      <th align="left"><a href="#1>>">1&gt;&gt;</a></th>
        <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td>
        <td align="left">right shift 1 bit and bring in a 1</td>
        </tr>
      <th align="left"><a href="#msb>>">msb&gt;&gt;</a></th>
        <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td>
        <td align="left">right shift 1 bit and keep the msb the same</td>
        </tr>
      <th align="left"><a href="#lsb>>">lsb&gt;&gt;</a></th>
        <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td>
        <td align="left">right shift 1 bit and rotate the lsb into the msb</td>
        </tr>
      <th align="left"><a href="#dup">dup</a></th>
        <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td>
        <td align="left">push a duplicate of the top of the data stack onto the data stack</td>
        </tr>
      <th align="left"><a href="#r@">r@</a></th>
        <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td>
        <td align="left">push a duplicate of the top of the return stack onto the data stack</td>
        </tr>
      <th align="left"><a href="#over">over</a></th>
        <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td>
        <td align="left">push a duplicate of the next-to-top of the data stack onto the data stack</td>
        </tr>
      <th align="left"><a href="#swap">swap</a></th>
        <td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td>
        <td align="left">swap the top and the next-to-top of the data stack</td>
        </tr>
      <th align="left"><a href="#+">+</a></th>
        <td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td>
        <td align="left">pop the stack and replace the top with N+T</td>
        </tr>
      <th align="left"><a href="#-">-</a></th>
        <td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td>
        <td align="left">pop the stack and replace the top with N-T</td>
        </tr>
      <th align="left"><a href="#&">&amp;</a></th>
        <td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td>
        <td align="left">pop the stack and replace the top with N &amp; T</td>
        </tr>
      <th align="left"><a href="#or">or</a></th>
        <td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td>
        <td align="left">pop the stack and replace the top with N | T</td>
        </tr>
      <th align="left"><a href="#^">^</a></th>
        <td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td>
        <td align="left">pop the stack and replace the top with N ^ T</td>
        </tr>
      <th align="left"><a href="#drop">drop</a></th>
        <td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td>
        <td align="left">drop the top value from the stack<tt>jumpc</tt>" to a function call</td>
        </tr>
      <th align="left"><a href="#nip">nip</a></th>
        <td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td>
        <td align="left">pop the next-to-top from the data stack</td>
        </tr>
      <th align="left"><a href="#dis">dis</a></th>
        <td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td>
        <td align="left">disable interrupts</td>
        </tr>
      <th align="left"><a href="#ena">ena</a></th>
        <td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td>
        <td align="left">enable interrupts</td>
        </tr>
      <th align="left"><a href="#0=">0=</a></th>
        <td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
        <td align="left">replace the top of the stack with "<tt>0xFF</tt>" if it is "<tt>0x00</tt>" (i.e., it is zero), otherwise replace it with "<tt>0x00</tt>"<br/>
        </tr>
      <th align="left"><a href="#0<>">0&lt;&gt;</a></th>
        <td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td>
        <td align="left">replace the top of the stack with "<tt>0xFF</tt>" if it is not "<tt>0x00</tt>" (i.e., it is non-zero), otherwise replace it with "<tt>0x00</tt>"<br/>
        </tr>
      <th align="left"><a href="#-1=">-1=</a></th>
        <td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td>
        <td align="left">replace the top of the stack with "<tt>0xFF</tt>" if it is "<tt>0xFF</tt>" (i.e., it is all ones), otherwise replace it with "<tt>0x00</tt>"<br/>
        </tr>
      <th align="left"><a href="#-1<>">-1&lt;&gt;</a></th>
        <td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td>
        <td align="left">replace the top of the stack with "<tt>0xFF</tt>" if it is not "<tt>0xFF</tt>" (i.e., it is not all ones), otherwise replace it with "<tt>0x00</tt>"<br/>
        </tr>
      <th align="left"><a href="#return">return</a></th>
        <td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td>
        <td align="left">return from a function call</td>
        </tr>
      <th align="left"><a href="#inport">inport</a></th>
        <td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td>
        <td align="left">replace the top of the stack with the contents of the specified input port</td>
        </tr>
      <th align="left"><a href="#outport">outport</a></th>
        <td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td>
        <td align="left">write the next-to-top of the data stack to the output port specified by the top of the data stack</td>
        </tr>
      <th align="left"><a href="#>r">&gt;r</a></th>
        <td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
        <td align="left">Pop the top of the data stack and push it onto the return stack</td>
        </tr>
      <th align="left"><a href="#r>">r&gt;</a></th>
        <td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td>
        <td align="left">Pop the top of the return stack and push it onto the data stack</td>
        </tr>
      <th align="left"><a href="#+uu">+uu</a></th>
        <td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td>
        <td align="left">16 bit result of unsigned(N) + unsigned(T)</td>
        </tr>
      <th align="left"><a href="#-uu">-uu</a></th>
        <td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td>
        <td align="left">16 bit result of unsigned(N) - unsigned(T)</td>
        </tr>
      <th align="left"><a href="#+us">+us</a></th>
        <td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td>
        <td align="left">16 bit result of unsigned(N) + signed(T)</td>
        </tr>
      <th align="left"><a href="#-us">-us</a></th>
        <td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td>
        <td align="left">16 bit result of unsigned(N) - signed(T)</td>
        </tr>
      <th align="left"><a href="#+su">+su</a></th>
        <td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td>
        <td align="left">16 bit result of signed(N) + unsigned(T)</td>
        </tr>
      <th align="left"><a href="#-su">-su</a></th>
        <td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td>
        <td align="left">16 bit result of signed(N) - unsigned(T)</td>
        </tr>
      <th align="left"><a href="#+ss">+ss</a></th>
        <td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td>
        <td align="left">16 bit result of signed(N) + signed(T)</td>
        </tr>
      <th align="left"><a href="#-ss">-ss</a></th>
        <td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td>
        <td align="left">16 bit result of signed(N) - signed(T)</td>
        </tr>
      <th align="left"><a href="#store">store</a></th>
        <td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>b</td><td>b</td><td>b</td>
        <td align="left">Store N in the T'th entry in bank "<tt>bbb</tt>" and pop the data stack</td>
        </tr>
      <th align="left"><a href="#fetch">fetch</a></th>
        <td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>b</td><td>b</td><td>b</td><td>b</td>
        <td align="left">Exchange the top of the stack with the T'th value from bank "<tt>bbbb</tt>"</td>
        </tr>
      <th align="left"><a href="#jump">jump</a></th>
        <td>0</td><td>1</td><td>0</td><td>0</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td>
        <td align="left">Jump to the address "<tt>x_xxxx_TTTT_TTTT</tt>"</td>
        </tr>
      <th align="left"><a href="#jumpc">jumpc</a></th>
        <td>0</td><td>1</td><td>0</td><td>1</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td>
        <td align="left">Conditionally jump to the address "<tt>x_xxxx_TTTT_TTTT</tt>"</td>
        </tr>
      <th align="left"><a href="#call">call</a></th>
        <td>0</td><td>1</td><td>1</td><td>0</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td>
        <td align="left">Call the function at address "<tt>x_xxxx_TTTT_TTTT</tt>"</td>
        </tr>
      <th align="left"><a href="#callc">callc</a></th>
        <td>0</td><td>1</td><td>1</td><td>1</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td>
        <td align="left">Conditionally call the function at address "<tt>x_xxxx_TTTT_TTTT</tt>"</td>
        </tr>
      <th align="left"><a href="#push">push</a></th>
        <td>1</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td>
        <td align="left">Push the 8-bit value "<tt>xxxx_xxxx</tt>" onto the data stack.</td>
        </tr>
    </table>
  <h2><a name="&">Instruction:  &amp;</a></h2>
    <b>Desription:</b>  Pop the data stack and replace the top with the bitwise
      and of the previous top and next-to-top.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; T &amp; N<br/>
      N &leftarrow; <tt>stack--</tt><br/>
      <br/>
  <h2><a name="+">Instruction:  +</a></h2>
    <b>Desription:</b>  Pop the data stack and replace the top with the
      8&nbsp;sum of the previous top and next-to-top.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; N + T<br/>
      N &leftarrow; <tt>stack--</tt><br/>
      <br/>
  <h2><a name="+ss">Instruction:  +ss</a></h2>
    <b>Desription:</b>  Replace the top and next-to-top of the data stack with
      their 16-bit signed sum.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; MSB(signed(N)+signed(T))<br/>
      N &leftarrow; LSB(signed(N)+signed(T))<br/><br/>
      <br/>
  <h2><a name="+su">Instruction:  +su</a></h2>
    <b>Desription:</b>  Replace the top and next-to-top of the data stack with
      their 16-bit sum where N is treated as signed and T is treated as
      unsigned.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; MSB(signed(N)+unsigned(T))<br/>
      N &leftarrow; LSB(signed(N)+unsigned(T))<br/><br/>
      <br/>
  <h2><a name="+us">Instruction:  +us</a></h2>
    <b>Desription:</b>  Replace the top and next-to-top of the data stack with
      their 16-bit sum where N is treated as unsigned and T is treated as
      signed.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; MSB(unsigned(N)+signed(T))<br/>
      N &leftarrow; LSB(unsigned(N)+signed(T))<br/><br/>
      <br/>
  <h2><a name="+uu">Instruction:  +uu</a></h2>
    <b>Desription:</b>  Replace the top and next-to-top of the data stack with
      their 16-bit unsigned sum.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; MSB(unsigned(N)+unsigned(T))<br/>
      N &leftarrow; LSB(unsigned(N)+unsigned(T))<br/><br/>
      <br/>
  <h2><a name="-">Instruction:  -</a></h2>
    <b>Desription:</b>  Pop the data stack and replace the top with the
      8&nbsp;difference of the previous top and next-to-top.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; N - T<br/>
      N &leftarrow; <tt>stack--</tt><br/>
      <br/>
  <h2><a name="-1<>">Instruction:  -1<></a></h2>
    <b>Desription:</b>  Set the top of the stack to all ones if the previous
      value was not all ones, otherwise set it to all zeros.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; 0xFF if T!=0xFF, 0x00 otherwise<br/>
      N and <tt>stack</tt> unchanged<br/>
      <br/>
  <h2><a name="-1=">Instruction:  -1=</a></h2>
    <b>Desription:</b>  Set the top of the stack to all ones if the previous
      value was all ones, otherwise set it to all zeros.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; 0xFF if T=0xFF, 0x00 otherwise<br/>
      N and <tt>stack</tt> unchanged<br/>
      <br/>
  <h2><a name="-ss">Instruction:  -ss</a></h2>
    <b>Desription:</b>  Replace the top and next-to-top of the data stack with
      their 16-bit signed difference.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; MSB(signed(N)-signed(T))<br/>
      N &leftarrow; LSB(signed(N)-signed(T))<br/><br/>
      <br/>
  <h2><a name="-su">Instruction:  -su</a></h2>
    <b>Desription:</b>  Replace the top and next-to-top of the data stack with
      their 16-bit difference where N is treated as signed and T is treated as
      unsigned.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; MSB(signed(N)-unsigned(T))<br/>
      N &leftarrow; LSB(signed(N)-unsigned(T))<br/><br/>
      <br/>
  <h2><a name="-us">Instruction:  -us</a></h2>
    <b>Desription:</b>  Replace the top and next-to-top of the data stack with
      their 16-bit difference where N is treated as unsigned and T is treated as
      signed.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; MSB(unsigned(N)-signed(T))<br/>
      N &leftarrow; LSB(unsigned(N)-signed(T))<br/><br/>
      <br/>
  <h2><a name="-uu">Instruction:  -uu</a></h2>
    <b>Desription:</b>  Replace the top and next-to-top of the data stack with
      their 16-bit unsigned difference.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; MSB(unsigned(N)-unsigned(T))<br/>
      N &leftarrow; LSB(unsigned(N)-unsigned(T))<br/><br/>
      <br/>
  <h2><a name="0<>">Instruction:  0<></a></h2>
    <b>Desription:</b>  Set the top of the stack to all ones if the previous
      value was not all zeros, otherwise set it to all zeros.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; 0xFF if T!=0x00, 0x00 otherwise<br/>
      N and <tt>stack</tt> unchanged<br/>
      <br/>
  <h2><a name="0=">Instruction:  0=</a></h2>
    <b>Desription:</b>  Set the top of the stack to all ones if the previous
      value was all zeros, otherwise set it to all zeros.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; 0xFF if T=0x00, 0x00 otherwise<br/>
      N and <tt>stack</tt> unchanged<br/>
      <br/>
  <h2><a name="0>>">Instruction:  0&gt;&gt;</a></h2>
    <b>Desription:</b>  Right shift the top of the stack one bit, replacing the
      left-most bit with a zero.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; { 0, T[7], T[6], ..., T[1] }<br/>
      N and <tt>stack</tt> unchanged<br/>
      <br/>
  <h2><a name="1>>">Instruction:  1&gt;&gt;</a></h2>
    <b>Desription:</b>  Right shift the top of the stack one bit, replacing the
      left-most bit with a zero.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; { 1, T[7], T[6], ..., T[1] }<br/>
      N and <tt>stack</tt> unchanged<br/>
      <br/>
  <h2><a name="<<0">Instruction:  &lt;&lt;0</a></h2>
    <b>Desription:</b>  Left shift the top of the stack one bit, replacing the
      right-most bit with a zero.
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; { T[6], T[5], ..., T[0], 0 }<br/>
      N and <tt>stack</tt> unchanged<br/>
      <br/>
  <h2><a name="<<1">Instruction:  &lt;&lt;1</a></h2>
    <b>Desription:</b>  Left shift the top of the stack one bit, replacing the
      right-most bit with a one.<br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; { T[6], T[5], ..., T[0], 1 }<br/>
      N and <tt>stack</tt> unchanged<br/>
      <br/>
  <h2><a name="<<msb">Instruction:  &lt;&lt;msb</a></h2>
    <b>Desription:</b>  Left shift the top of the stack one bit, leaving the
      right-most bit unchanged.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; { T[6], T[5], ..., T[0], T[7] }<br/>
      N and <tt>stack</tt> unchanged<br/>
      <br/>
  <h2><a name=">r">Instruction:  &gt;r</a></h2>
    <b>Desription:</b>  Pop the data stack and push its previous value onto the
      return stack.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R &leftarrow; T<br/>
      <tt>++return</tt> &leftarrow; R<br/>
      T &leftarrow; N<br/>
      N &leftarrow; <tt>stack--</tt><br/>
      <br/>
  <h2><a name="^">Instruction:  ^</a></h2>
    <b>Desription:</b>  Pop the data stack and replace the top with the bitwise
      exclusive or of the previous top and next-to-top.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; T ^ N<br/>
      N &leftarrow; <tt>stack--</tt><br/>
      <br/>
  <h2><a name="call">Instruction:  call</a></h2>
    <b>Desription:</b>  Call the function at the address constructed from the
      opcode and <tt>T</tt>.  Discard&nbsp;<tt>T</tt> and push the PC onto the
      return stack.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; { O[4], ..., O[0], T[7], T[6], ..., T[0] }<br/>
      R &leftarrow; PC+1<br/>
      <tt>++return</tt> &leftarrow; R<br/>
      T &leftarrow; N<br/>
      N &leftarrow; <tt>stack--</tt><br/>
      <br/>
    <b>Special:</b><br/><br/>
      Interrupts are disabled during the clock cycle immediately following a
      call instruction.<br/><br/>
      The assembler normally places a "<tt>nop</tt>" instruction immediately
      after the "<tt>call</tt>" instruction.<br/><br/>
  <h2><a name="callc">Instruction:  callc</a></h2>
    <b>Desription:</b>  Conditionally call the function at the address
      constructed from the opcode and <tt>T</tt>.  Discard&nbsp;<tt>T</tt> and
      conditionally push the next PC onto the return stack.<br/><br/>
    <b>Operation:</b><br/><br/>
      if N != 0 then<br/>
      &nbsp;&nbsp;PC &leftarrow; { O[4], ..., O[0], T[7], T[6], ..., T[0] }<br/>
      &nbsp;&nbsp;R &leftarrow; PC<br/>
      &nbsp;&nbsp;<tt>++return</tt> &leftarrow; R<br/>
      else<br/>
      &nbsp;&nbsp;PC &leftarrow; PC+1<br/>
      &nbsp;&nbsp;R and <tt>return</tt> unchanged<br/>
      endif<br/>
      T &leftarrow; N<br/>
      N &leftarrow; <tt>stack--</tt><br/>
      <br/>
    <b>Special:</b><br/><br/>
      Interrupts are disabled during the clock cycle immediately following a
      callc instruction.<br/><br/>
      The assembler normally places a "<tt>drop</tt>" instruction immediately
      after the "<tt>callc</tt>" instruction.<br/><br/>
  <h2><a name="dis">Instruction:  dis</a></h2>
    <b>Desription:</b>  Disable interrupts.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R, <tt>return</tt>, T, N, and <tt>stack</tt> unchanged</br>
      <br/>
  <h2><a name="drop">Instruction:  drop</a></h2>
    <b>Desription:</b>  Pop the data stack, discarding the value that had been
      on the top.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; N<br/>
      N &leftarrow; <tt>stack--</tt><br/>
      <br/>
  <h2><a name="dup">Instruction:  dup</a></h2>
    <b>Desription:</b>  Push the top of the data stack onto the data
      stack.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; T<br/>
      N &leftarrow; T<br/>
      <tt>++stack</tt> &leftarrow; N<br/>
      <br/>
  <h2><a name="ena">Instruction:  ena</a></h2>
    <b>Desription:</b>  Enable interrupts.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R, <tt>return</tt>, T, N, and <tt>stack</tt> unchanged</br>
      <br/>
  <h2><a name="fetch">Instruction:  fetch</a></h2>
    <b>Desription:</b>  Replace the top of the data stack with an 8&nbsp;bit
      value from memory.  The memory bank is specified by the four
      least-significant bits of the opcode.  The index within the memory bank is
      specified by the previous value of the top of the stack.<br/><br/>
    <b>Operation:</b><br/><br/>
      TODO<br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; bbbb[T] where "bbbb" is the bank<br/>
      N and <tt>stack</tt> unchanged<br/>
      <br/>
  <h2><a name="inport">Instruction:  inport</a></h2>
    <b>Desription:</b>  Replace the top of the data stack with the 8&nbsp;value
      from the port specified by the previous value of the top of the data
      stack.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; <tt>input_port</tt>[T]<br/>
      N and <tt>stack</tt> unchanged<br/>
      <br/>
    <b>Special:</b><br/><br/>
      The recommended procedure to read from an inport port is to use the
      "<tt>.inport</tt>" macro.<br/><br/>
  <h2><a name="jump">Instruction:  jump</a></h2>
    <b>Desription:</b>  Jump to the address constructed from the opcode and
      <tt>T</tt>.  Discard&nbsp;<tt>T</tt>.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; { O[4], ..., O[0], T[7], T[6], ..., T[0] }<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; N<br/>
      N &leftarrow; <tt>stack--</tt><br/>
      <br/>
    <b>Special:</b><br/><br/>
      Interrupts are disabled during the clock cycle immediately following a
      jump instruction.<br/><br/>
      The assembler normally places a "<tt>nop</tt>" instruction immediately
      after the "<tt>jump</tt>" instruction.<br/><br/>
  <h2><a name="jumpc">Instruction:  jumpc</a></h2>
    <b>Desription:</b>  Jump to the address constructed from the opcode and
      <tt>T</tt> if <tt>N</tt> is non-zero.  Discard <tt>S</tt>
      and&nbsp;<tt>N</tt>.<br/><br/>
    <b>Operation:</b><br/><br/>
      if N != 0 then<br/>
      &nbsp;&nbsp;PC &leftarrow; { O[4], ..., O[0], T[7], T[6], ..., T[0] }<br/>
      else<br/>
      &nbsp;&nbsp;PC &leftarrow; PC+1<br/>
      end if<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; N<br/>
      N &leftarrow; <tt>stack--</tt><br/>
      <br/>
    <b>Special:</b><br/><br/>
      Interrupts are disabled during the clock cycle immediately following a
      jumpc instruction.<br/><br/>
      The assembler normally places a "<tt>drop</tt>" instruction immediately
      after the "<tt>jump</tt>" instruction so that the conditional is dropped
      from the data stack.<br/><br/>
  <h2><a name="lsb>>">Instruction:  lsb&gt;&gt;</a></h2>
    <b>Desription:</b>  Right shift the top of the stack one bit, replacing the
      left-most bit with the previous value of the right-most bit.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; { T[0], T[7], T[6], ..., T[1] }<br/>
      N and <tt>stack</tt> unchanged<br/>
      <br/>
  <h2><a name="msb>>">Instruction:  msb&gt;&gt;</a></h2>
    <b>Desription:</b>  Right shift the top of the stack one bit, preserving the
      value of the left-most bit.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; { T[7], T[7], T[6], ..., T[1] }<br/>
      N and <tt>stack</tt> unchanged<br/>
      <br/>
  <h2><a name="nip">Instruction:  nip</a></h2>
    <b>Desription:</b>  Discard the next-to-top value on the data
      stack.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <return</tt> unchanged<br/>
      T &leftarrow; T<br/>
      N &leftarrow; <tt>stack--</tt><br/>
      <br/>
  <h2><a name="nop">Instruction:  nop</a></h2>
    <b>Desription:</b>  No operation.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow PC + 1<br/>
      R, <tt>return</tt>, T, N, and <tt>stack</tt> unchanged<br/>
      <br/>
  <h2><a name="or">Instruction:  or</a></h2>
    <b>Desription:</b>  Pop the data stack and replace the top with the bitwise
      or of the previous top and next-to-top.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; T or N<br/>
      N &leftarrow; <tt>stack--</tt><br/>
      <br/>
  <h2><a name="outport">Instruction:  outport</a></h2>
    <b>Desription:</b>  Pop the data stack and write the previous next-to-top to
      the port specified by the previous top.<br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; N<br/>
      N &leftarrow; <tt>stack--</tt><br/>
      <tt>outport</tt>[T] &leftarrow; N<br/>
      <br/>
    <b>Special:</b><br/><br/>
      This instruction must be following by a "<tt>drop</tt>" in order to
      discard the value from the data stack that had been written to the data
      port.  The recommended procedure to write to an output port is to use the
      "<tt>.outport</tt>" macro.<br/><br/>
  <h2><a name="over">Instruction:  over</a></h2>
    <b>Desription:</b>  Push the next-to-top of the data stack onto the data
      stack.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; N<br/>
      N &leftarrow; T<br/>
      <tt>++stack</tt> &leftarrow; N<br/>
      <br/>
  <h2><a name="push">Instruction:  push</a></h2>
    <b>Description:</b>  Push the specified 8-bit value onto the 8-bit
      stack.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; <tt>opcode</tt>[7:0]<br/>
      N &leftarrow; T<br/>
      <tt>++stack</tt> &leftarrow; N<br/>
      <br/>
  <h2><a name="r>">Instruction:  r&gt;</a></h2>
    <b>Desription:</b>  Pop the return stack and push its previous value onto
      the data stack.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R &leftarrow; <tt>return--</tt><br/>
      T &leftarrow; R<br/>
      N &leftarrow; T<br/>
      <tt>++stack</tt> &leftarrow; N<br/>
      <br/>
  <h2><a name="r@">Instruction:  r@</a></h2>
    <b>Desription:</b>  Push the top of the return stack onto the data
      stack.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; R<br/>
      N &leftarrow; T<br/>
      <tt>++stack</tt> &leftarrow; N<br/>
  <h2><a name="return">Instruction:  return</a></h2>
    <b>Description:</b>  Popd the top of the return stack into the PC.<br/><br/>
    <b>Operation:</b><br/><br/>
      TODO<br/><br/>
      PC &leftarrow; R<br/>
      R &leftarrow; <tt>return--</tt><br/>
      T, N, and <tt>stack</tt> unchanged<br/>
      <br/>
    <b>Special:</b>
      This instruction must be followed by a "<tt>nop</tt>"
      instruction.<br/><br/>
  <h2><a name="store">Instruction:  store</a></h2>
    <b>Desription:</b>  Pop the data stack and store the previous next-to-top of
      the data stack at the memory location specified by the previous top of the
      data stack.  The memory bank is specified by the three least significant
      bits of the opcode.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; N<br/>
      N &leftarrow; <tt>stack--</tt><br/>
      bbb[T] &leftarrow; N where "<tt>bbb</tt>" is the bank<br/>
      <br/>
    <b>Special:</b>
      The recommended procecure is to use the "<tt>.store</tt>" macro.<br/><br/>
  <h2><a name="swap">Instruction:  swap</a></h2>
    <b>Desription:</b>  Swap the top two values on the data stack.<br/><br/>
    <b>Operation:</b><br/><br/>
      PC &leftarrow; PC+1<br/>
      R and <tt>return</tt> unchanged<br/>
      T &leftarrow; N<br/>
      N &leftarrow; T<br/>
      <tt>stack</tt> unchanged<br/>
      <br/>
<h1>Assembler</h1>
  This section describes the contents of an assembly language file and the
    instruction format.<br/><br/>
  The following is a simple, 10 instruction sequence, demonstrating a
    loop:<br/><br/>
    <tt>&nbsp;&nbsp;;&nbsp;consume&nbsp;256*6+3&nbsp;clock&nbsp;cycles</tt><br/>
    <tt>&nbsp;&nbsp;0&nbsp;:l00&nbsp;1&nbsp;-&nbsp;dup&nbsp;.jumpc(l00)&nbsp;drop&nbsp;.return</tt><br/><br/>
  This looks a lot like Forth code in that the operations are single words and
    are strung together on a single line.  Unlike traditional assembly
    languages, there are no source and destination registers, so most of the
    operations for this stack-based processor simply manipulate the stack.  This
    can make it easier to see the body of the assembly code since an instruction
    sequence can occupy a single line of the file instead of tens of lines of
    vertical space.  The exceptions to the single-operand format are labels,
    such as the "<tt>:l00</tt>" which are declared with a single "<tt>:</tt>"
    immediately followed by the name of the label with no intervening spaces;
    jump instructions such as the 3&nbsp;instruction,
    "<tt>push&nbsp;jumpc&nbsp;drop</tt>", sequence created by the
    "<tt>.jumpc</tt>" macro; and the 2&nbsp;operand, "<tt>return&nbsp;nop</tt>",
    sequence created by the "<tt>.return</tt>" macro.  The "<tt>.jump</tt>",
    "<tt>.jumpc</tt>", "<tt>.call</tt>", and "<tt>.callc</tt>", macros are
    pre-defined in the assembler and ensure that the correct sequence of
    operands is generated for the jump, conditional jump, function call, and
    conditional function call instructions.  Similarly, the "<tt>.return</tt>"
    macro is pre-defined in the assember and ensures that the correct sequence
    of operations is done for returning from a called function.<br/><br/>
  Memory does not have to be declared for the processor.  For example, the LED
    flashing examples required no variable or constant storage, and therefore do
    not declare or consume resources required for memory.  Variable declarations
    are done within pages declared using the "<tt>.page</tt>" and
    "<tt>.variable</tt>" macros as follows:<br/><br/>
    <tt>&nbsp;&nbsp;.page&nbsp;RAM&nbsp;myRAM</tt><br/>
    <tt>&nbsp;&nbsp;.variable&nbsp;save_count</tt><br/>
    <tt>&nbsp;&nbsp;.variable&nbsp;old_count&nbsp;.x0a</tt><br/>
    <tt>&nbsp;&nbsp;.variable&nbsp;out_string&nbsp;.length&nbsp;16</tt><br/><br/>
    Here, the "<tt>.page&nbsp;RAM</tt>" macro declares the start of a page
    of&nbsp;RAM.  The RAM will be allocated as prescribed in the processor
    description file.  Here, the variable "<tt>save_count</tt>" will be at
    memory address "<tt>0x00</tt>" and will occupy a single, uninitialized slot
    of memory.  The variable "<tt>old_count</tt>" will also occupy a single slot
    of memory at address "<tt>0x01</tt>" and will be initialized to the hex
    value "<tt>0x0a</tt>".  Note that if the processor is reset that this value
    will not be re-initialized.  Finally, the variable "<tt>out_string</tt>"
    will start at address "<tt>0x02</tt>" and will occupy 16 bytes of
    memory.<br/><br/>
  A&nbsp;ROM is declared similarly.  For example,<br/><br/>
    <tt>&nbsp;&nbsp;.page&nbsp;ROM&nbsp;myROM</tt><br/>
    <tt>&nbsp;&nbsp;.variable&nbsp;hex_to_ascii&nbsp;'0'&nbsp;'1'&nbsp;'2'&nbsp;'3'&nbsp;'4'&nbsp;'5'&nbsp;'6'&nbsp;'7'&nbsp;\&nbsp;;&nbsp;first&nbsp;8&nbsp;characters</tt><br/>
    <tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'8'&nbsp;'9'&nbsp;'A'&nbsp;'B'&nbsp;'C'&nbsp;'D'&nbsp;'E'&nbsp;'F'</tt><br/><br/>
    declares a page of ROM with the 16&nbsp;element array hex_to_ascii
    initialized with the values required to convert a 4-bit value to the
    corresponding hex ascii character.  This also illustrates how the
    initialization sequence (and length determination) can be continued on
    multiple lines.  If&nbsp;"<tt>outbyte</tt>" is a function that outputs a
    single byte to a port, then the hex value of a one-byte value can be output
    using the following sequence:<br/><br/>
    <tt>&nbsp;&nbsp;dup&nbsp;0&gt;&gt;&nbsp;0&gt;&gt;&nbsp;0&gt;&gt;&nbsp;0&gt;&gt;&nbsp;hex_to_ascii&nbsp;+&nbsp;.fetch(myROM)&nbsp;.call(outbyte)</tt><br/>
    <tt>&nbsp;&nbsp;.x0F&nbsp;and&nbsp;hex_to_ascii&nbsp;+&nbsp;.fetch(myROM)&nbsp;.call(outbyte)</tt><br/><br/>
    The first line extracts the most significant nibble of the byte by right
    shifting it 4 times while filling the left with zeros, adding that value to
    the address "<tt>hex_to_ascii</tt>" to get the corresponding ascii
    character, fetching that value from the ROM named "<tt>myROM</tt>", and then
    calling the function that consumes that value on the top of the stack while
    sending it to the output port (this takes 11 instructions).  The second line
    extracts the least significant nibble using an "<tt>and</tt>" instructions
    and then proceeds similarly (this takes 8 instructions).  The
    "<tt>.fetch</tt>" macro generates the "<tt>fetch</tt>" instruction using the
    3&nbsp;bit value of "<tt>myROM</tt>" as part of the memory address
    generation.<br/><br/>
  The "<tt>.store</tt>" macro is similar to the "<tt>.fetch</tt>" macro except
    that the assembler will generate an error message if a "<tt>store</tt>"
    operation is attempted to a ROM page.<br/><br/>
  Two additional variants of the "<tt>.fetch</tt>" and "<tt>.store</tt>" macros
    are provided.  The first, "<tt>.fetch(save_count)</tt>" will generate the
    2&nbsp;instruction sequence consisting of (1)&nbsp;the instruction to push
    the 8&nbsp;bit address of "<tt>save_count</tt>" onto the stack and
    (2)&nbsp;the "<tt>fetch</tt>" instruction with the 3&nbsp;bit page number
    associated with "<tt>save_count</tt>".  This helps ensure the correct page
    is used when accessing "<tt>save_count</tt>".  The instruction
    "<tt>store(save_count)</tt>" is similar.  The second variant of these is for
    indexed fetches and stores.  For example, the preceding example to convert
    the single-byte value to hex could be written as<br/><br/>
    <tt>&nbsp;&nbsp;dup&nbsp;0&gt;&gt;&nbsp;0&gt;&gt;&nbsp;0&gt;&gt;&nbsp;0&gt;&gt;&nbsp;.fetchindexed(hex_to_ascii)&nbsp;.call(outbyte)</tt><br/>
    <tt>&nbsp;&nbsp;.x0F&nbsp;and&nbsp;.fetchindexed(hex_to_ascii)&nbsp;.call(outbyte)</tt><br/><br/>
    Here, the macro "<tt>.fetchindexed</tt>" consumes the top of the data stack
    as an index into the array variable "<tt>hex_to_ascii</tt>" and pushes the
    indexed value onto the top of the data stack.<br/><br/>
  The "<tt>store</tt>" instruction must be followed by a drop instruction since
    it consumes the top two values in the data stack.  The "<tt>.store</tt>" and
    "<tt>.storeindexed</tt>" macros generate this drop function automatically.
    Thus, "<tt>.store(myRAM)</tt>" generates the 2&nbsp;instruction sequence
    "<tt>store&nbsp;drop</tt>", "<tt>.store(save_count)</tt>" generates the
    3&nbsp;instruction sequence "<tt>save_count&nbsp;store&nbsp;drop</tt>", and
    "<tt>.storeindexed(out_string)</tt>" generates the 4&nbsp;instruction
    sequence "<tt>out_string&nbsp;+&nbsp;store&nbsp;drop</tt>", all with the
    proviso that the "<tt>store</tt>" instructions include the 3&nbsp;bit
    address&nbsp;"<tt>myRAM</tt>".<br/><br/>
</body>
</html>
