<!-- Copyright 2012, Sinclair R.F., Inc. -->
<html>
<title>
9-bit opcode, 8-bit data stack-based micro controller
</title>
<body>
<b>9-bit Opcode, 8-bit Data Stack-Based Micro Controller</b><br/>
Copyright 2012, Sinclair R.F., Inc.<br/><br/>
This document describes a 9-bit opcode, 8-bit data, stack-based microcontroller.
<h1>Introduction</h1>
  The objective of this design is to provide a minimalist FPGA-based
    microcontroller.<br/><br/>
  A&nbsp;9-bit opcode was chosen because (1)&nbsp;it works well with Altera,
    Lattice, and Xilinx SRAM widths and (2)&nbsp;it allows pushing 8-bit data
    onto the stack with a single instruction.<br/><br/>
  An&nbsp;8-bit data width was chosen because that's a practical minimal sizes
    and is common to many hardware interfaces such as I2C devices.<br/><br/>
  The machine has single-cycle instruction execution for all
    instructions.<br/><br/>
  This architecture accommodates up to a 14-bit instructions address space by
    first pushing the 8 least significant bits of the destination address onto
    the stack and then encoding the 6 most significant bits in the jump
    instruction.  This is the largest practicable instruction address width
    because (1)&nbsp;one bit of the opcode is required to indicate pushing an
    8-bit value onto the stack, (2)&nbsp;one bit of the remaining 8 bits is
    required to indicate a jump instructions, and (3)&nbsp;one more bit is
    required to indicate whether the jump is always performed or is
    conditionally performed.  Consuming these 3 bits leaves 6 bit for the msb
    of the jump address.<br/><br/>
<h1>Design</h1>
  This section describes things the processor does not do and what is required
    in code to work around these restrictions:<br/><br/>
  <ul>
    <li>Data Stack Operations:<br/><br/>
      While the large SRAMs and distributed memory can be dual port, minimizing
        the FPGA resources required for the processor means that the stack
        memory and the program ROM frequently share a single SRAM.  That
        requirement prohibits using dual port memory operations for the stack.
        Also, the requirement that all instructions be single-cycle means that
        only one stack operation can be performed per clock cycle.<br/><br/>
      The large SRAM on the FPGAs can have registers for their input addresses
        and values and registers for their output data.  These registers are
        used to extract the fastests speed possible from the memory.  While it
        is possible to design the stack operations to avoid these registers,
        that isn't always what's desired.  This however impacts how stack
        operations are performed.<br/><br/>
      Implementing the "<tt>rot</tt>" instruction, i.e., if
        "<tt>1&nbsp;2&nbsp;3</tt>" are the top 3 elements of the data stack with
        "<tt>3</tt>" on the top of the stacks, then "<tt>rot</tt>" changes the
        stack to "<tt>2&nbsp;3&nbsp;1</tt>", would seem to require immediate
        access to the third element on the stack.  However, the instruction
        sequence "<tt>&gt;r&nbsp;swap&nbsp;r&gt;swap</tt>" has the same effect
        and only requires access to the top two elements of the data stack, but
        does require that the return stack be implemented.<br/><br/>
      This means that only the first two elements of the stack need to be
        accessible.  That is "<tt>S</tt>" must be implemented in a registers.
        The question then is, can "<tt>N</tt>" be implemented as the output of
        the data stack with the input address register and output data register,
        or must it also be implemented as a separate register?  Suppose that the
        data stack address or the top element in the data stack SRAM changes
        during clock cycle&nbsp;<em>n</em>.  Then the new value for "<tt>N</tt>"
        will not be available until clock cycle&nbsp;<em>n</em>+2.  This means
        that the preceding implementation for the "<tt>rot</tt>" operation would
        have to be implemented as
        "<tt>&gt;r&nbsp;nop&nbsp;swap&nbsp;nop&nbsp;r&gt;nop&nbsp;swap</tt>".
        This substantially impairs the efficiency of the program, which means
        that the value of "<tt>N</tt>" must be stored in a register separate
        from the SRAM register.<br/><br/>
      Then, in order to implement the "<tt>drop</tt>" instruction, the output of
        the SRAM must be the third value on the stack.  In&nbsp;order to
        immediately follow one "<tt>drop</tt>" instruction with another, the
        output of the SRAM must immediately change to the next previous value on
        the data stack.  I.e., if <em>SP</em> is the stack pointer, then
        <em>SP</em>-1 points to the memory location where "<tt>N</tt>" would be
        stored, <em>SP</em>-2 points to the third value on the stack, etc., then
        the input address to the stack pointer memory must be <em>SP</em>-3.
        When the first "<tt>drop</tt>" instruction is performed, the contents of
        "<tt>N</tt>" will be stored by the "<tt>T</tt>" register, the output of
        the SRAM register will be stored by the "<tt>N</tt>" register, the
        output register of the SRAM will be enabled to store the unregister
        output of the internal memory and will have the new value for the third
        element on the stack.  Simultaneously, the input address register for
        the SRAM will latch the new value of <em>SP</em>-3 so that the internal,
        unregistered output of the SRAM will be the new fourth element on the
        stack.  This will allow "<tt>drop</tt>" instructions to be issued
        sequentially with no intermiediate "<tt>nop</tt>"
        instructions.<br/><br/>
      A&nbsp;problem with these scheme occurs if a "<tt>drop</tt>" or
        "<tt>nip</tt>" instruction is preceded by a write instruction to the
        stack.  Suppose the top 3 values in the data stack are
        "<tt>1&nbsp;2&nbsp;3</tt>" and the instruction sequence
        "<tt>4&nbsp;nip</tt>" is performed during clock cycle&nbps;<em>n</em>.
        At the end of clock cycle <em>n</em>, the input data and address
        registers for the SRAM will be "<tt>2</tt>" and the new value for
        <em>SP</em>-2.  At&nbsp;the same time, the output register will still
        have the value&nbsp;"<tt>1</tt>" because that is the value that had been
        pointed to by the previously registered input address.  In&nbsp;order
        for the subsequent "<tt>nip</tt>" instruction to work properly, the
        output register should have the value&nbsp;"<tt>2</tt>".  Since the
        memory write is actually done during clock cycle <em>n</em>+1, there
        really isn't a practical way to have the SRAM output register have the
        correct value at the end of clock cycle&nbsp;<em>n</em>.  This defect
        can be corrected by requiring a "<tt>nop</tt>" instruction between the
        two instructions, swapping the order of the push and "<tt>nip</tt>"
        instructions and replacing the "<tt>nip</tt>" instruction with a
        "<tt>drop</tt>" instruction (if the "<tt>nip</tt>" instruction is not
        the target of a jump), or by adding a third data stack register.  None
        of these options is really attractive, however requiring users to
        remember to add "<tt>nop</tt>" instructions is the least attractive, so
        an additional, third data stack register is required.<br/><br/>
      Now, if "<tt>0&nbsp;1&nbsp;2&nbsp;3</tt>" are the values in the top of the
        data stack and the instruction sequence "<tt>4&nbsp;nip</tt>" is
        started during clock cycle&nbps;<em>n</em>, then at then end of clock
        cycle <em>n</em> the three data stack registers will be "<tt>2</tt>",
        "<tt>3</tt>", and "<tt>4</tt>", the input data and address registers to
        the SRAM will be "<tt>1</tt>" and <em>SP-3</em> respectively. and the
        contents of the SRAM output register will be invalid.  At&nbsp;the end
        of clock cycle <em>n</em>+1 the values of the "<tt>T</tt>" and
        "<tt>N</tt>" will be "<tt>4</tt>" and "<tt>2</tt>" respectively, the
        third data stack register will be invalid (since there is no good value
        to store in it), and the SRAM output register will have the new contents
        for the third data stack register.<br/><br/>
      For the following, let "<tt>T</tt>", "<tt>N</tt>", and "<tt>I</tt>" be the
        registers for the top of the stack, the next element on the stack, the
        intermediate register and let "<tt>R</tt>" be the output register of the
        SRAM.  The data stack manipulation must be such that "<tt>T</tt>" and
        "<tt>N</tt>" are always value.  Then, in order for a "<tt>drop</tt>" or
        "<tt>nip</tt>" instruction to opertate successfully, either "<tt>I</tt>"
        or "<tt>R</tt>" must have the third value on the stack and, if
        "<tt>R</tt>" does not already have the fourth value on the stack, it
        must do so by the end of the next clock cycle.<br/><br/>
      Supposed the top 4 elements on the stack are
        "<tt>0&nbsp;1&nbsp;2&nbsp;3</tt> and these are stored in the registers
        "<tt>R</tt>", "<tt>I</tt>", "<tt>N</tt>", and "<tt>T</tt>" respectively.
        Then the instruction sequence "<tt>4&nbsp;nip</tt>" started on clock
        cycle&nbsp;<em>n</em> will have the following effects.  At&nbsp; the end
        of clock cycle&nbsp<em>n</em>, the registers "<tt>T</tt>", "<tt>N</tt>",
        and "<tt>I</tt>" will be valid and have the values "<tt>4</tt>",
        "<tt>3</tt>", and "<tt>2</tt>" respectively, the SRAM input data and
        address registers will have the values "<tt>1</tt>" and <em>SP</em>-3
        respectively, and the SRAM output register will have the value
        "<tt>0</tt>", which is not valid.  After the "<tt>nip</tt>" instruction,
        at&nbsp;the end of clock cycle&nbsp;<em>n</em>+1, the "<tt>T</tt>" will
        be unchanged at "<tt>4</tt>" and will be valid; the "<tt>N</tt>" will
        have taken its value from "<tt>I</tt>", which had been valid, and will
        be "<tt>2</tt>", the "<tt>I</tt>" register will not have a valid value,
        and the "<tt>R</tt>" register will have the value "<tt>1</tt>" if the
        SRAM had been configured for write-through operation, which will be the
        valid valud for the third element on the stack as is required since the
        value of "<tt>I</tt>" is not valid.  At&nbsp;the same time, the input
        address register for the SRAM must be the new value of
        <em>SP</em>-3.<br/><br/>
      </li>
    <li>JUMP and JUMPC:<br/><br/>
      The large SRAM on the FPGAs can have registers for their input addresses
        and registers for their output data.  These registers are used to extract
        the fastest speed possible from the memory.  While it is possible to
        design the processor ROM to avoid these registers, that isn't always
        what's desired.  This however impacts how jump instructions are
        performed.<br/><br/>
      Specifically, if a jump instruction changes the program counter during
        cycle <em>n</em>, then the new input address is registered at the end of that
        clock cycle and the corresponding data is registered at the end of the
        next clock cycle, i.e., the new opcode is available at the end of cycle
        <em>n</em>+1.  That is, the new opcode isn't performed by the core until
        cycle&nbsp;<em>n</em>+2.<br/><br/>
      This means that JUMP and JUMPC instructions must be followed by a TBD
        instruction.<br/><br/>
      TODO -- should "TBD" be a "nop", a "drop", or push the PC onto the return
        stack?<br/><br/>
      </li>
    </ul>
<h1>OPCODES</h1>
  This section documents the opcodes.<br/><br/>
  Alphabetic listing:
    <a href="#call">call</a>,
    <a href="#callc">callc</a>,
    <a href="#jump">jump</a>,
    <a href="#jumpc">jumpc</a>,
    <a href="#nop">nop</a>,
    <a href="#push">push</a>,
    <br/><br/>
  <h2>TODO -- add these instructions</h2>
    +<br/>
    -<br/>
    &gt;r -- push top of data stack onto return stack<br/>
    0&lt; -- (or used "0x80 and" instead?)<br/>
    0=<br/>
    2*<br/>
    2/<br/>
    and<br/>
    call<br/>
    dis -- disable the interrupt<br/>
    drop<br/>
    ena -- enable the interrupt<br/>
    fetch (@) -- read from memory<br/>
    in -- input from port<br/>
    or<br/>
    out -- output to port<br/>
    r&gt; -- pop the return stack and push that value onto the data stack<br/>
    r@ -- push a copy of the top of the return stack onto the data stack<br/>
    reset?<br/>
    return<br/>
    returnc -- ?<br/>
    rot -- rotate top 3 elements of the data stack (use "&gt;r swap r&gt; swap" instead?<br/>
    rotate -- left or right, carry in is 0<br/>
    rotate with carry -- left or right, carry in is msb/lsb<br/>
    store (!) -- write to memory<br/>
    swap<br/>
    xor<br/>
    <br/>
  <h2><a name="opcode_mapping">Opcode Mapping</a></h2>
    Add:  call, callc<br/><br/>
    <table>
    <tr>
      <th align="left">Opcode</th>
        <th>8</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th>
        <th align="left">Description</th>
        </tr>
      <th align="left">nop</th>
        <td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td>
        <td align="left">no operation</td>
        </tr>
      <th align="left">jump</th>
        <td>0</td><td>1</td><td>0</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td>
        <td align="left">Jump to the address "<tt>xx_xxxx_TTTT_TTTT</tt>"</td>
        </tr>
      <th align="left">jumpc</th>
        <td>0</td><td>1</td><td>1</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td>
        <td align="left">Conditionally jump to the address "<tt>xx_xxxx_TTTT_TTTT</tt>"</td>
        </tr>
      <th align="left">push</th>
        <td>1</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td><td>x</td>
        <td align="left">Push the 8-bit value "<tt>xxxx_xxxx</tt>" onto the data stack.</td>
        </tr>
    </table>
  <h2><a name="call">Instruction:  call</a></h2>
    <b>Desription:</b>  Convert the immediately preceding "<tt>jump</tt>"
      instruction into a function call by pushing the PC onto the return
      stack.<br/><br/>
    <b>OPCODE:</b>  <tt>TBD</tt><br/><br/>
    <b>Operation:</b><br/><br/>
      TODO
    <b>Special:</b><br/><br/>
      A&nbsp;function call consists of the following 3 opcode instruction
      sequence:  "<tt>LL&nbsp;jump_MM&nbsp;call</tt>" where "<tt>LL</tt>" is the
      instruction to push the 8&nbsp;lsb of the function address onto the stack,
      "<tt>jump_MM</tt>" is the jump instruction along with the 6&nbsp;msb of
      the function address, and "<tt>call</tt>" is the instruction to push the
      PC onto the return stack.<br/><br/>
  <h2><a name="callc">Instruction:  callc</a></h2>
    <b>Desription:</b>  Convert the immediately preceding "<tt>jumpc</tt>"
      instruction into a function call by pushing the PC onto the return
      stack and dropping the conditional for the jump from the data
      stack.<br/><br/>
    <b>OPCODE:</b>  <tt>TBD</tt><br/><br/>
    <b>Operation:</b><br/><br/>
      TODO
    <b>Special:</b><br/><br/>
      A&nbsp;conditional function call consists of the following 3 opcode
      instruction sequence:  "<tt>LL&nbsp;jumpc_MM&nbsp;callc</tt>" where
      "<tt>LL</tt>" is the instruction to push the 8&nbsp;lsb of the function
      address onto the stack, "<tt>jumpc_MM</tt>" is the jump instruction along
      with the 6&nbsp;msb of the function address, and "<tt>callc</tt>" is the
      instruction to push the PC onto the return stack and to drop the
      conditional for the jump from the top of the stack.<br/><br/>
  <h2><a name="jump">Instruction:  jump</a></h2>
    <b>Desription:</b>  Jump to the address constructed from the opcode and
      <tt>S</tt>.  Discard&nbsp;<tt>S</tt>.<br/><br/>
    <b>OPCODE:</b>  <tt>0_10xx_xxxx</tt><br/><br/>
    <b>Operation:</b><br/><br/>
      TODO
    <b>Special:</b><br/><br/>
      Interrupts are disabled during the clock cycle immediately following a
      jump instruction.<br/><br/>
  <h2><a name="jumpc">Instruction:  jumpc</a></h2>
    <b>Desription:</b>  Jump to the address constructed from the opcode and
      <tt>S</tt> if <tt>N</tt> is non-zero.  Discard <tt>S</tt>
      and&nbsp;<tt>N</tt>.<br/><br/>
    <b>OPCODE:</b>  <tt>0_11xx_xxxx</tt><br/><br/>
    <b>Operation:</b><br/><br/>
      TODO
    <b>Special:</b><br/><br/>
      Interrupts are disabled during the clock cycle immediately following a
      jumpc instruction.<br/><br/>
  <h2><a name="nop">Instruction:  nop</a></h2>
    <b>Desription:</b>  No operation.<br/><br/>
    <b>Operation:</b><br/><br/>
      TODO
  <h2><a name="push">Instruction:  push</a></h2>
    <b>Description:</b>  Push the specified 8-bit value onto the 8-bit
      stack.<br/><br/>
    <b>OPCODE:</b>  <tt>1_xxxx_xxxx</tt><br/><br/>
    <b>Operation:</b><br/><br/>
      TODO
</body>
</html>
