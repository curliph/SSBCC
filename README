SSBCC is a Small Stack-Based Computer Compiler with a 9-bit opcode, 8-bit data
core.  It is intended to provide an FPGA-vendor independent micro-controller
suitable for external communications and FPGA fabric control using relatively
few FPGA resources.  It can, for example, receive commands from an external SPI
master, operate the associated FPGA cores as commanded, and perform error
detection and reporting.

The computer compiler uses an architectural description of the processor stating
the sizes of the instruction memory, data stack, and return stack; the input and
output ports; memory types and sizes; and peripherals.  It outputs a single
module implementing the entire micro controller.

The 9x8 instructions are all single-cycle.  The instructions include pushing an
8-bit value onto the data stack;  arithmetic operations:  addition, subtraction,
increment, and decrement;  bit-wise logical operations:  and, or, and exclusive
or; rotations;  logical operations:  0=, 0<>, -1=, -1<>; data and return stack
operations:  dup, over, swap, drop, nip, >r, r>, and r@; input and output port
operations;  memory read and write with optional address increment and
decrement;  jumps and conditional jumps;  calls and conditional calls;  and
function return.

The 9x8 address space is up to 8K.  This is achieved by pushing the 8 lsb of the
target address onto the data stack immediately before a jump or call instruction
and by encoding the 5 msb of the address within the jump or call instruction.
The instruction immediately following a jump, call, or return is executed before
the instruction sequence at the target address or return address is executed.

Up to four banks of memory, either RAM or ROM, are available.  Each of these can
be up to 256 bytes, providing a total of up to 1 kB of memory.

The assembly language is Forth-like.  Macros are used to encode the jump and
call instructions and to encode the 2-bit memory bank index in memory store and
fetch instructions.

The computer compiler and assembler are written in Python 2.7.  Peripherals are
implemented by Python modules which generate the I/O ports and the peripheral
HDL.  This provides an extensible peripheral set to the compiler.

The computer compiler is documented in the doc directory.  The 9x8 core is
documented in the core/9x8/doc directory.  Several examples are provided.

The processor has placed and routed at 210 MHz in a Spartan 6 while consuming 43
slices.

This is a beta release.  While the computer compiler and assembler are fully
functional and there are no known bugs, features and peripherals are still being
added and the documentation is incomplete.  Also, the output HDL is currently
restricted to Verilog.  VHDL will be added when everything else is complete.
The processor is being used on a commercial project and the examples have been
run on hardware.


EXAMPLE:
================================================================================

The LED flasher example demonstrates the simplicity of the architectural
specification and the Forth-like assembly language.

The architecture file, named "led.9x8", with the comments and user header
removed, is as follows:

  ARCHITECTURE    core/9x8 Verilog

  INSTRUCTION     2048
  RETURN_STACK    32
  DATA_STACK      32

  PORTCOMMENT LED on/off signal
  OUTPORT 1-bit o_led O_LED

  ASSEMBLY led.s

The ARCHITECTURE configuration command specifies the 9x8 core.  The INSTRUCTION,
RETURN_STACK, and DATA_STACK configuration commands specify the sizes of the
instruction space, return stack, and data stack.  The content of the PORTCOMMENT
configuration command is inserted in the module declaration -- this facilitates
identifying signals in micro controllers with a lot of inputs and outputs.  The
single OUTPORT statement specifies a 1-bit signal named "o_led."  This signal is
accessed in the assembly code through the symbol "O_LED."  The ASSEMBLY command
specifies the single input file "led.s," which is listed below.  Finally, the
HDL statement specifies the Verilog language with the output going to "led.v".

The "led.s" assembly file is as follows:

  ; Consume 256*5+3 clock cycles.
  ; ( - )
  .function pause
    0 :inner 1- dup .jumpc(inner) drop
  .return

  ; Repeat "pause" 256 times.
  ; ( - )
  .function repause
    0 :inner .call(pause) 1- dup .jumpc(inner) drop
  .return

  ; main program (as an infinite loop)
  .main
    0 :inner 1 ^ dup .outport(O_LED) .call(repause) .jump(inner)

This example is coded in a traditional Forth structure with the conditional
jumps consuming the top of the data stack.  Examining the "pause" function, the
".function" directive specifies the start of a function and the function name.
The "0" instruction pushes the value "0" onto the top of the data stack.
":inner" is a label for a jump instruction.  The "1-" instruction decrements the
top of the data stack.  "dup" is the Forth instruction to push a duplicate of
the top of the data stack onto the data stack.  The ".jumpc(inner)" macro
expands to three instructions as follows:  (1) push the 8 lsb of the address of
"inner" onto the data stack, (2) the conditional jump instruction with the 5 msb
of the address of "inner" (the jump instruction also drops the top of the data
stack with its partial address), and (3) a "drop" instruction to drop the new
top of the data stack, which was the conditional evaluated by the "jumpc"
instruction.

The function "repause" calls the "pause" function 256 times.  The main program
body is identified by the directive ".main"  This function runs an infinite loop
that toggles the lsb of the LED output, outputs the LED setting, and calls the
"repause" function.

A tighter version of the loop in the "pause" function can be written as

  0xFF :inner .jumpc(inner,1-) drop

which is 3 cycles long for each iteration and the "drop" that is normally part
of the "jumpc" macro has been replaced by the decrement instruction.

The instruction memory initialization for the processor module includes the
instruction mnemonics being performed at each address and replaces the "list"
file output from traditional assemblers.  The following is the memory
initialization for this LED flasher example.  The main program always starts at
address zero and functions are included in the order encountered.  Unused
library functions are not included in the generated instruction list.

  reg [8:0] s_opcodeMemory[2047:0];
  initial begin
    // .main
    s_opcodeMemory['h000] = 9'h100; // 0x00
    s_opcodeMemory['h001] = 9'h101; // :inner 0x01
    s_opcodeMemory['h002] = 9'h052; // ^
    s_opcodeMemory['h003] = 9'h008; // dup
    s_opcodeMemory['h004] = 9'h100; // O_LED
    s_opcodeMemory['h005] = 9'h038; // outport
    s_opcodeMemory['h006] = 9'h054; // drop
    s_opcodeMemory['h007] = 9'h10D; // 
    s_opcodeMemory['h008] = 9'h0C0; // call repause
    s_opcodeMemory['h009] = 9'h000; // nop
    s_opcodeMemory['h00A] = 9'h101; // 
    s_opcodeMemory['h00B] = 9'h080; // jump inner
    s_opcodeMemory['h00C] = 9'h000; // nop
    // repause
    s_opcodeMemory['h00D] = 9'h100; // 0x00
    s_opcodeMemory['h00E] = 9'h119; // :inner 
    s_opcodeMemory['h00F] = 9'h0C0; // call pause
    s_opcodeMemory['h010] = 9'h000; // nop
    s_opcodeMemory['h011] = 9'h05C; // 1-
    s_opcodeMemory['h012] = 9'h008; // dup
    s_opcodeMemory['h013] = 9'h10E; // 
    s_opcodeMemory['h014] = 9'h0A0; // jumpc inner
    s_opcodeMemory['h015] = 9'h054; // drop
    s_opcodeMemory['h016] = 9'h054; // drop
    s_opcodeMemory['h017] = 9'h028; // return
    s_opcodeMemory['h018] = 9'h000; // nop
    // pause
    s_opcodeMemory['h019] = 9'h100; // 0x00
    s_opcodeMemory['h01A] = 9'h05C; // :inner 1-
    s_opcodeMemory['h01B] = 9'h008; // dup
    s_opcodeMemory['h01C] = 9'h11A; // 
    s_opcodeMemory['h01D] = 9'h0A0; // jumpc inner
    s_opcodeMemory['h01E] = 9'h054; // drop
    s_opcodeMemory['h01F] = 9'h054; // drop
    s_opcodeMemory['h020] = 9'h028; // return
    s_opcodeMemory['h021] = 9'h000; // nop
    s_opcodeMemory['h022] = 9'h000;
    s_opcodeMemory['h023] = 9'h000;
    s_opcodeMemory['h024] = 9'h000;
    ...
    s_opcodeMemory['h7FF] = 9'h000;
  end


INPORT and OUTPORT
================================================================================

The INPORT and OUTPORT configuration commands are used to specify 2-state inputs
and outputs.  For example

  INPORT 8-bit i_value I_VALUE

specifies a single 8-bit input signal named "i_value" for the module.  The port
is accessed in assembly by ".inport(I_VALUE)" which is equivalent to the
two-instruction sequence "I_VALUE inport."  To input an 8-bit value from a FIFO
and send a single-clock-cycle wide acknowledgment strobe, use

  INPORT 8-bit,strobe i_fifo,o_fifo_ack I_FIFO

The assembly ".inport(I_FIFO)" will automatically send an acknowledgment strobe
to the FIFO through "o_fifo_ack."

A write port to an 8-bit FIFO is similarly specified by

  OUTPORT 8-bit,strobe o_fifo,o_fifo_wr O_FIFO

The assembly ".outport(O_FIFO)" which is equivalent to "O_FIFO outport drop"
will automatically send a write strobe to the FIFO through "o_fifo_wr."

Multiple signals can be packed into a single input or output port by defining
them in comma separated lists.  The associated bit masks can be defined
coincident with the port definition as follows:

  INPUT 1-bit,1-bit i_fifo_full,i_fifo_empty I_FIFO_STATUS
  CONSTANT C_FIFO_STATUS__FULL  0x02
  CONSTANT C_FIFO_STATUS__EMPTY 0x01

Checking the "full" status of the FIFO can be done by the following assembly
sequence:

  .inport(I_FIFO_STATUS) C_FIFO_STATUS__FULL &

Multiple bits can be masked using a computed value as follows:

  .inport(I_FIFO_STATUS) ${C_FIFO_STATUS__FULL|C_FIFO_STATUS__EMPTY} &

The "${...}" creates an instruction to push the 8-bit value in the braces onto
the data stack.  The computation is performed using the Python "eval" function
in the context of the program constants, memory addresses, and memory sizes.

Preceding all of these by

  PORTCOMMENT external FIFO

produces the following in the Verilog module statement.  The I/O ports are
listed in the order in which they are declared.

  // external FIFO
  input  wire       [7:0] i_fifo,
  output reg              o_fifo_ack,
  output reg        [7:0] o_fifo,
  output reg              o_fifo_wr,
  input  wire             i_fifo_full,
  input  wire             i_fifo_empty

The HDL to implement the inputs and outputs is computer generated.  Identifying
the port name in the architecture file eliminates the possibility of
inconsistent port numbers between the HDL and the assembly.  Specifying the bit
mapping for the assembly code immediately after the port definition helps
prevent inconsistencies between the port definition and the bit mapping in the
assembly code.

An isolated output strobe can also be created using:

  OUTPORT strobe o_strobe O_STROBE

The associated assembly does not require an output value for the port so that
the strobe can be generated with the two instruction sequence "O_STROBE
outport".

A single-bit "set-reset" input port type is also included.  This sets a register
when an external strobe is received and clears the register when the port is
read.  For example, to capture an external timer for a polled-loop, include the
following in the architecture file:

  PORTCOMMENT external timer
  INPORT set-reset i_timer I_TIMER

The following is the assembly code to conditionally call two functions when the
timer event is encountered:

  .inport(I_TIMER)
    .callc(timer_event_1,nop)
    .callc(timer_event_2)

The "nop" in the first conditional call prevents the conditional from being
dropped from the data stack so that it can be used by the subsequent conditional
function call.


PERIPHERAL
================================================================================

Peripherals are implemented via Python modules.  For example, an open drain I/O
signal, such as is required for an I2C bus, does not fit the INPORT and OUTPORT
functionality.  Instead, an "open_drain" peripheral is provided by the Python
script in "core/9x8/peripherals/open_drain.py."  This puts a tri-state I/O in
the module statement, allows it to be read through an "inport" instruction, and
allows it to be set low or released through an "outport" instruction.  An I2C
bus with separate SCL and SDA ports can then be incorporated into the processor
as follows:

  PORTCOMMENT     I2C bus
  PERIPHERAL      open_drain      inport=I_SCL \
                                  outport=O_SCL \
                                  iosignal=io_scl
  PERIPHERAL      open_drain      inport=I_SDA \
                                  outport=O_SDA \
                                  iosignal=io_sda

The default width for this peripheral is 1 bit.  The module statement will then
include the lines

  // I2C bus
  inout  wire     io_scl,
  inout  wire     io_sda

The assembly code to set the io_scl signal low is "0 .outport(O_SCL)" and to
release it is "1 .outport(O_SCL)".  These instruction sequences are actually
"0 O_SCL outport drop" and "1 O_SCL outport drop" respectively.  The "outport"
instruction drops the top of the data stack (which contained the port number)
and sends the next-to-the-top of the data stack to the designated output port.

Two examples of I2C device operation are included in the examples directory.


PARAMETER and LOCALPARAM
================================================================================

Parameters are incorporated through the PARAMETER and LOCALPARAM configuration
commands.  For example, the clock frequency in hertz is needed for UARTs for
their baud rate generator.  The configuration command

  PARAMETER G_CLK_FREQ_HZ 97_000_000

specifies the clock frequency as 97 MHz.  The HDL instantiating the processor
can change this specification.  The frequency can also be changed through the
command-line invokation of the computer compiler.  For example,

  ssbcc -G "G_CLK_FREQ_HZ=100_000_000" myprogram.9x8

specifies a frequency of 100 MHz instead of the default frequency of 97 MHz.

The LOCALPARAM configuration command can be used to specify parameters that
should not be changed by the surrounding HDL.  For example,

  LOCALPARAM L_VERSION 24'h00_00_00

specifies a 24-bit parameter named "L_VERSION".  The 8-bit major, minor, and
build sections of the parameter can be accessed in an assembly program using
"L_VERSION[16+:8]", "L_VERSION[8+:8]", and "L_VERSION[0+:8]".

For both parameters and localparams, the default range is "[0+:8]".  The
instruction memory is initialized using the parameter value during synthesis,
not the value used to initialize the parameter.  That is, the instruction memory
initialization will be:

  s_opcodeMemory[...] = { 1'b1, L_VERSION[16+:8] };

The value of the localparam can be set when the computer compiler is run using
the "-G" option.  For example,

  ssbcc -G "L_VERSION=24'h01_04_03" myprogram.9x8

can be used in a makefile to set the version number for a release without
modifying the micro controller architecture file.


DIAGNOSTICS AND DEBUGGING
================================================================================

The stack health can be monitored during simulation by including the
"monitor_stack" peripheral through the command line.  For example, the LED
flasher example can be generated using

  ssbcc -P monitor_stack led.9x8

This allows the architecture file to be unchanged between simulation and an FPGA
build.

Stack errors include underflow and overflow, malformed data validity, and
incorrect use of the values on the return stack (returns to data values and data
operations on return addresses).  Other errors include out-of-range for memory,
inport, and outport operations.

When stack errors are detected the last 50 instructions are dumped to the
console and the simulation terminates.  This facilitates diagnosing coding
errors.  The dump includes the PC, numeric opcode, textual representation of the
opcode, data stack pointer, next-to-top of the data stack, top of the data
stack, top of the return stack, and the return stack pointer.  Invalid stack
values are displayed as "XX".  The length of the history dumped is configurable.

Out-of-range PC checks are also performed if the instruction space is not a
power of 2.

A "trace" peripheral is also provided that dumps the entire execution history.
This was used to validate the processor core.


RESOURCE ALLOCATION
================================================================================

The DATA_STACK, RETURN_STACK, INSTRUCTION, and MEMORY configuration commands
allocate memory for the data stack, instruction ROM, memory RAM and ROM, and the
return stack respectively.  The COMBINE configuration command is used to
coalesce the allocated memories, thereby reducing the FPGA resources required to
implement the processor or make it more usable on architectures that do not have
distributed memory.  The SRAM_WIDTH configuration command is use to specify FPGA
architectures with block memories more than 9 bits wide.

The DATA_STACK configuration command allocates memory for the data stack.  It
has the form "DATA_STACK N" where N is the commanded size of the data stack.
N must be a power of 2.

The RETURN_STACK configuration command allocates memory for the return stack and
has the same format as the DATA_STACK configuration command.

The INSTRUCTION configuration allocates memory for the processor instruction
space.  It has the form "INSTRUCTION N" or "INSTRUCTION N*M" where N must be a
power of 2.  The first form is used if the desired instruction memory size is a
power of 2.  The second form is used to allocate M memory blocks of size N.  For
example, on an Altera Cyclone III, the configuration command
"INSTRUCTION 1024*3" allocates three M9Ks for the instruction space, saving one
M9K as compared to the configuration command "INSTRUCTION 4096".

The MEMORY configuration command is used to define one to four memories, either
RAM or ROM, with up to 256 bytes.  If no MEMORY configuration command is issued,
then no memories are allocated for the processor.  The MEMORY configuration
command has the format "MEMORY {RAM|ROM} name N" where "{RAM|ROM}" specifies
either a RAM or a ROM, name is the name of the memory and must start with an
alphabetic character, and the size of the memory, N, must be a power of 2.  For
example, "MEMORY RAM myram 64" allocates 64 bytes of memory to form a RAM named
myram.  Similarly, "MEMORY ROM lut 256" defines a 256 byte ROM named lut.

The COMBINE configuration command can be used to combine the various memories
for more efficient processor implementation as follows:

The configuration command "COMBINE MEMORY" will combine all of the memories,
irrespective of whether they are RAMs or ROMs and irrespective of their size
into the smallest single-port memory resource possible.  If a list of memories
is provided, for example "COMBINE MEMORY(ram_a,ram_b,rom_c)," then the stated
memories will be combined instead of all of the memories.

The configuration command "COMBINE INSTRUCTION,mem_type {N|N*M}" is used to
place the stated memory type at the end of the INSTRUCTION memory space.
mem_type can be MEMORY, MEMORY(list), DATA_STACK, or RETURN_STACK.  If this
command is used then it replaces the INSTRUCTION configuration command.  If the
return stack is combined with the instruction memory space, then it may use two
instruction addresses for each return stack entry.  For example, the
configuration command "COMBINE INSTRUCTION,RETURN_STACK 1024" requires 10 bits
for each return stack entry.  Since this doesn't fit in the presumed 9-bit
memory width, two instruction addresses are required for each return stack
entry.

The COMBINE configuration command can be used to combine any two of the
following: MEMORY or MEMORY(list), DATA_STACK, or RETURN_STACK.  For example,
"COMBINE MEMORY,DATA_STACK" will place all of the memories and the data stack in
the same dual-port memory.  The same applies if a list of memory names is
provided as an argument to MEMORY.

The SRAM_WIDTH configuration command is used to make the memory allocations more
efficient when the memory block width is more than 9 bits.  For example,
Altera's Cyclone V family has 10-bit wide memory blocks and the configuration
command "SRAM_WIDTH 10" is appropriate.  For example, the configuration command
sequence

  RETURN_STACK    32
  SRAM_WIDTH      10
  COMBINE         INSTRUCTION,RETURN_STACK 1024

will use a single 10-bit memory entry for each element of the return stack
instead of packing the 10-bit values into two memory entries of a 9-bit wide
memory.

The following illustrates a possible configuration for a Spartan-6 with a
2048-long SRAM and relatively large 64-deep data stack.  The data stack will be in
the last 64 elements of the instruction memory.

  DATA_STACK 64
  COMBINE    INSTRUCTION,DATA_STACK 2048

The following illustrates a possible configuration for a Cyclone-III with three
M9Ks for the instruction ROM and the data stack.

  DATA_STACK 64
  COMBINE INSTRUCTION,DATA_STACK 1024*3


SIMULATIONS
================================================================================

Simulations have been performed with Icarus Verilog, Verilator, and Xilinx'
ISIM.  Icarus Verilog is good for short, simple simulations, Verilator for long
simulations of large, complex systems, and ISIM when Xilinx-specific cores are
used.  Verilator is over an order of magnitude faster than the other simulators
I've used.
