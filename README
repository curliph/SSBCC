SSBCC is a Small Stack-Based Computer Compiler with a 9-bit opcode, 8-bit data
core.

The computer compiler is documented in the doc directory.  The 9x8 core is
documented in the core/9x8/doc directory.  Several examples are provided.

This is a beta release.  While the computer compiler and assembler are fully
functional and there are no known bugs, features are still being added and the
documentation is incomplete.  Also, the output HDL is currently restricted to
Verilog.  VHDL will be added when everything else is complete.  The processor is
being used on a commercial project and the examples do work on hardware.

The 9x8 instructions are all single-cycle.  Jumps and calls require 2
instructions to encode the 13-bit address.  The RISC architecture means that the
instructions immediately following jumps, calls, and returns are always
executed.

The processor has placed and routed at 210 MHz in a Spartan 6 while consuming 43
slices.

INTRODUCTION
================================================================================

SSBCC.9x8 is intended to provide a complete processor implementation structure
while using relatively few FPGA resources.

The computer compiler takes an architecture definition file and creates a single
module which implements the desired architecture, I/Os, data and return stacks,
memories, and peripherals.  It also runs the assembler and incorporates the
instructions into the module.

The computer compiler and assembler are written in Python 2.7.  The 9x8 assembly
is Forth-like.  The instruction space can be up to 8K.

EXAMPLE:
================================================================================

The LED flasher example demonstrates the simplicity of the architectural
specification and the Forth-like assembly language.

The architecture file (with the comments and user header removed) is as follows:

  ARCHITECTURE core/9x8

  INSTRUCTION             2048
  RETURN_STACK            32
  DATA_STACK              32

  PORTCOMMENT LED on/off signal
  OUTPORT 1-bit o_led O_LED

  ASSEMBLY led.s
  HDL Verilog led

The ARCHITECTURE configuration command specifies the 9x8 core.  The INSTRUCTION,
RETURN_STACK, and DATA_STACK configuration commands specify the lengths of the
instruction space, return stack length, and data stack length.  The content of
the PORTCOMMENT configuration command is inserted in the module declaration --
this facilitates identifying signals in micro controllers with a lot of inputs
and outputs.  The single OUTPORT statement specifies a 1-bit signal named
"o_led."  This signal is accessed in the assembly code through the symbol
"O_LED."  The ASSEMBLY command specifies the single input file "led.s," which is
listed below.  Finally, the HDL statement specifies the Verilog language with
the output going to "led.v"

The "led.s" assembly file is as follows:

  ; Consume 256*5+3 clock cycles.
  ; ( - )
  .function pause
    0 :inner 1- dup .jumpc(inner) drop
  .return

  ; Repeat "pause" 256 times.
  ; ( - )
  .function repause
    0 :inner .call(pause) 1- dup .jumpc(inner) drop
  .return

  ; main program (as an infinite loop)
  .main
    0 :inner 1 ^ dup .outport(O_LED) .call(repause) .jump(inner)

This example is coded in a traditional Forth structure with the conditional
jumps consuming the top of the data stack.  Examining the "pause" function, the
".function" directive specifies the start of a function and the function name.
The "0" instruction pushes the value "0" onto the top of the data stack.
":inner" is a label for a jump instruction.  The "1-" instruction decrements the
top of the data stack.  "dup" is the Forth instruction to push a duplicate of
the top of the data stack onto the data stack.  The ".jumpc(inner)" macro
expands to three instructions as follows:  (1) push the 8 lsb of the address of
"inner" onto the data stack, (2) the conditional jump instruction with the 5 msb
of the address of "inner" (the jump instruction also drops the top of the data
stack with its partial address), and (3) a "drop" instruction to drop the new
top of the data stack, which was the conditional evaluated by the "jumpc"
instruction.

The function "repause" calls the "pause" function 256 times.  The main program
body is identified by the directive ".main"  This function runs an infinite loop
that toggles the lsb of the LED output, outputs the LED setting, and calls the
"repause" function.

A tighter version of the loop in the "pause" function can be written as

  0xFF :inner .jumpc(inner,1-) drop

which is 3 cycles long for each iteration and the "drop" that is normally part
of the "jumpc" macro has been replaced by the decrement instruction.

The instruction memory initialization for the processor module includes the
instruction mnemonics being performed at each address and replaces the "list"
file output from traditional assemblers.  The following is the memory
initialization for this LED flasher example.  The main program always starts at
address zero and functions are included in the order encountered.  Unused
library functions are not included in the generated instruction list.

  reg [8:0] s_opcodeMemory[2047:0];
  initial begin
    // .main
    s_opcodeMemory['h000] = 9'h100; // 0x00
    s_opcodeMemory['h001] = 9'h101; // :inner 0x01
    s_opcodeMemory['h002] = 9'h052; // ^
    s_opcodeMemory['h003] = 9'h008; // dup
    s_opcodeMemory['h004] = 9'h100; // O_LED
    s_opcodeMemory['h005] = 9'h038; // outport
    s_opcodeMemory['h006] = 9'h054; // drop
    s_opcodeMemory['h007] = 9'h10D; // 
    s_opcodeMemory['h008] = 9'h0C0; // call repause
    s_opcodeMemory['h009] = 9'h000; // nop
    s_opcodeMemory['h00A] = 9'h101; // 
    s_opcodeMemory['h00B] = 9'h080; // jump inner
    s_opcodeMemory['h00C] = 9'h000; // nop
    // repause
    s_opcodeMemory['h00D] = 9'h100; // 0x00
    s_opcodeMemory['h00E] = 9'h119; // :inner 
    s_opcodeMemory['h00F] = 9'h0C0; // call pause
    s_opcodeMemory['h010] = 9'h000; // nop
    s_opcodeMemory['h011] = 9'h05C; // 1-
    s_opcodeMemory['h012] = 9'h008; // dup
    s_opcodeMemory['h013] = 9'h10E; // 
    s_opcodeMemory['h014] = 9'h0A0; // jumpc inner
    s_opcodeMemory['h015] = 9'h054; // drop
    s_opcodeMemory['h016] = 9'h054; // drop
    s_opcodeMemory['h017] = 9'h028; // return
    s_opcodeMemory['h018] = 9'h000; // nop
    // pause
    s_opcodeMemory['h019] = 9'h100; // 0x00
    s_opcodeMemory['h01A] = 9'h05C; // :inner 1-
    s_opcodeMemory['h01B] = 9'h008; // dup
    s_opcodeMemory['h01C] = 9'h11A; // 
    s_opcodeMemory['h01D] = 9'h0A0; // jumpc inner
    s_opcodeMemory['h01E] = 9'h054; // drop
    s_opcodeMemory['h01F] = 9'h054; // drop
    s_opcodeMemory['h020] = 9'h028; // return
    s_opcodeMemory['h021] = 9'h000; // nop
    s_opcodeMemory['h022] = 9'h000;
    s_opcodeMemory['h023] = 9'h000;
    s_opcodeMemory['h024] = 9'h000;
    ...
    s_opcodeMemory['h7FF] = 9'h000;
  end

INPORT and OUTPORT
================================================================================

The INPORT and OUTPORT configuration commands are used to specify normal 2-state
inputs and outputs.  For example

  INPORT 8-bit i_value I_VALUE

specifies a single 8-bit input signal named "i_value" for the module.  The port
is accessed in assembly through the symbol "I_VALUE."  To input an 8-bit value
from a FIFO and send a single-clock-cycle wide acknowledgment strobe, use

  INPORT 8-bit,strobe i_fifo,o_fifo_ack I_FIFO

A write port to an 8-bit FIFO is similarly specified by

  OUTPORT 8-bit,strobe o_fifo,o_fifo_wr O_FIFO

Multiple signals can be packed into a single input or output port by defining
them in comma separated lists.  The masks can also be defined coincident with
the port definition as follows:

  INPUT 1-bit,1-bit i_fifo_full,i_fifo_empty I_FIFO_STATUS
  CONSTANT C_FIFO_STATUS__FULL  0x02
  CONSTANT C_FIFO_STATUS__EMPTY 0x01

Individual bits can then be masked as follows:

  .inport(I_FIFO_STATUS) C_FIFO_STATUS__FULL &

while multiple bits can be masked using a computed value as follows:

  .inport(I_FIFO_STATUS) ${C_FIFO_STATUS__FULL|C_FIFO_STATUS__EMPTY} &

The "${...}" is an instruction to push the 8-bit value in the braces onto the
data stack.  The computation is performed using the Python "eval" function in
the context of the program constants, memory addresses, and memory sizes.

Preceding all of these by

  PORTCOMMENT external FIFO

produces the following in the Verilog module statement:

  // external FIFO
  input  wire     i_fifo,
  output reg      o_fifo_ack,
  output reg      o_fifo,
  output reg      o_fifo_wr,
  input  wire     i_fifo_full,
  input  wire     i_fifo_empty

The HDL to implement the inputs and outputs is computer generated.  Identifying
the port name in the architecture file eliminates the possibility of
inconsistent port numbers between the HDL and the assembly.  Specifying the bit
mapping for the assembly code immediately after the port mapping reduces the
chances of inconsistencies between the port definition and the bit-mapping in
the assembly code.

An isolated output strobe can also be created using:

  OUTPORT strobe o_strobe O_STROBE

The associated assembly does not require a value for the port so that the strobe
can be generated with the two instruction sequence "O_STROBE outport".

A single-bit "set-reset" input port type is also included.  This sets the
associated register when an external strobe is received and clears the register
when the port is read.  For example, to capture an external timer for a
polled-loop, include the following in the architecture file:

  PORTCOMMENT external timer
  INPORT set-reset i_timer I_TIMER

and then conditionally call two functions if the timer event was encountered:

  .inport(I_TIMER)
    .callc(timer_event_1,nop)
    .callc(timer_event_2)

The "nop" in the first conditional call prevents the conditional from being
dropped from the data stack so that it can be used by the subsequent conditional
function call.

PERIPHERAL
================================================================================

Peripherals are implemented via Python modules.  For example, an open drain I/O
signal, such as is required for an I2C bus, does not conveniently fit the INPORT
and OUTPORT functionality.  Instead, an "open_drain" peripheral is provided by
the Python script in "cores/9x8/peripherals/open_drain.py."  This incorporates a
tri-state I/O in the module statement, allows it to be read through an "inport"
instruction, and allows it to be set low or released through an "outport"
instruction.  An I2C bus with separate SCL and SDA ports can then be
incorporated into the processor as follows:

  PORTCOMMENT     I2C bus
  PERIPHERAL      open_drain      inport=I_SCL \
                                  outport=O_SCL \
                                  iosignal=io_scl
  PERIPHERAL      open_drain      inport=I_SDA \
                                  outport=O_SDA \
                                  iosignal=io_sda

The default width for this peripheral is 1 bit.  The module statement will then
include the lines

  // I2C bus
  inout  wire     io_scl,
  inout  wire     io_sda

The assembly code to set the io_scl signal low is "0 .outport(O_SCL)" and to
release it is "1 .outport(O_SCL)".  These instruction sequences are actually
"0 O_SCL outport drop" and "1 O_SCL outport drop" respectively.  The "outport"
instruction also drops the top of the data stack (which contained the port
number).

DIAGNOSTICS AND DEBUGGING
================================================================================

The stack health can be monitored during simulation by including the
"monitor_stack" peripheral through the command line.  For example, the LED
flasher example can be generated using

  ssbcc -P monitor_stack led.9x8

This allows the architecture file to be unchanged between simulation and an FPGA
build.

Stack errors include underflow and overflow, malformed data validity, and
incorrect use of the values on the return stack (returns to data values and data
operations on return addresses).

SIMULATIONS
================================================================================

Simulations have been performed with Icarus Verilog, Verilator, and Xilinx'
ISIM.  Icarus Verilog is good for short, simple simulations, Verilator for long
simulations of larger, more complex systems, and ISIM when Xilinx-specific cores
are used.
